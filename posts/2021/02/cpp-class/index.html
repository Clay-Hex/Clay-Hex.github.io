<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;学习记录(5) 类 | Clay&#39;s Blog</title>
<meta name="keywords" content="C&#43;&#43;">
<meta name="description" content="c&#43;&#43;中的类">
<meta name="author" content="Clay">
<link rel="canonical" href="https://www.ClayHex.com/posts/2021/02/cpp-class/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://www.ClayHex.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.ClayHex.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.ClayHex.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.ClayHex.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.ClayHex.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://www.ClayHex.com/posts/2021/02/cpp-class/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><meta property="og:title" content="C&#43;&#43;学习记录(5) 类" />
<meta property="og:description" content="c&#43;&#43;中的类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ClayHex.com/posts/2021/02/cpp-class/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-17T14:56:45+08:00" />
<meta property="article:modified_time" content="2021-02-17T14:56:45+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;学习记录(5) 类"/>
<meta name="twitter:description" content="c&#43;&#43;中的类"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📒 记录",
      "item": "https://www.ClayHex.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚 学习",
      "item": "https://www.ClayHex.com/posts/learn/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "C++学习记录(5) 类",
      "item": "https://www.ClayHex.com/posts/2021/02/cpp-class/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++学习记录(5) 类",
  "name": "C\u002b\u002b学习记录(5) 类",
  "description": "c++中的类",
  "keywords": [
    "C++"
  ],
  "articleBody": "0. 类的4个默认函数 4个函数：构造函数、析构函数、拷贝构造函数、赋值号重载函数。\n在定义类时，如果没有自定义这些函数，编译器会提供默认的函数，在默认的函数中，构造函数、析构函数默认空实现，拷贝构造函数、赋值号重载函数默认是浅拷贝。\n拷贝构造函数作用：\n参数是一个同类型的对象，直接拷贝这个参数的所有属性，注意，这个拷贝默认是浅拷贝，需要深拷贝的话需要重载拷贝构造函数。 【注】\n如果在实例化一个对象的时候，后边加了一个空括号，编译器会认为这是一个函数声明而不是实例化，所以，如果一个类的构造函数没有参数的时候，实例化时不用附加空括号. Person a(); // 这样会认为是一个函数声明 Person a; // 应该这样 不要用拷贝构造函数去初始化一个匿名对象，否则从编译器会认为这是重定义。\n可以像这样给构造函数传参Person aaa = 10; 隐式转换法。\n如果没有自定义构造函数的话，C++会自动分配空的构造函数和 只会浅拷贝的拷贝构造函数\n1. 类的访问说明符（访问权限） public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问； protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问； private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象访问。 三者都允许友元访问。 protected和public的区别就在于类的类外可不可以调用。 protected和private的区别就在于子类是否可以访问，private权限给的最小，子类都不可以访问。 总结：按照类的对象是否可以访问，可以将后两个分成一类，按照子类是否可以访问，可以将前两个分成一类。\n2. 友元 对于不完全开放的protected和private中的成员，类 可以为友元函数（类）提供单独的访问权限。\n全局函数可以做友元 类可以做友元 类的成员函数可以做友元 友元函数的声明必须在类内，最好是在类的开始位置。但是友元函数的定义或者说实现即可在在类内，也可以在类外。\n友元的声明仅仅指定了访问权限，而非通常意义上的函数声明，如果我们希望类的用户可以调用某个友元函数，那么我们就必须在友元声明之外，再专门对该函数进行一次声明（提供给用户）。\n为了方便，通常把友元的声明与类本身放置在同一个头文件中（类的外部单独对该函数声明，以备外部调用方便）。\n类内进行友元函数定义，相当于定义了一个全局函数。 参考代码：\n#include using namespace std; class Person{ friend void test(){ // 友元函数声明 + 定义，如果不加friend的话，相当于一个普通的成员 cout \u003c\u003c 123 \u003c\u003c endl; } public: int a; }; // test函数的定义在Person类的内部，现在想使用它，必须单独进行声明，告诉编译器，我已经定义了test函数，直接调用没问题。 void test(); int main(){ test(); return 0; } 3. 内联函数 一般来说，内联机制用于优化规模较小、流程简单、频繁调用的函数。\n在编译时，直接把内联函数替换到调用它的地方，这样就省去了运行时调用函数的开销。\n类内定义的成员函数默认都是inline的。 类外定义的成员函数默认都不是inline的，想使用的话，可以加上inline说明。同时，需要把类的定义和该类外定义的成员函数 放在同一个文件中，否则编译时找不到内联函数。 4. 深拷贝与浅拷贝 如果没有自定义构造函数的话，C++会自动分配空的构造函数和 只会浅拷贝的拷贝构造函数\n在执行拷贝构造函数的时候，如果第一个对象 a1 在堆上开了一个指针 p 指向的地址是0x0011，a2使用a1进行初始化（使用拷贝构造函数复制a1的值）。所有属性完全复制，所以a2中的p所指的地址也是0x0011，并没有重新开辟一个堆的空间。所以如果a1先被释放了的话，a2再使用这个指针进行操作，就会产生异常了。\n#include #include #include using namespace std; class TEST{ public: TEST(int a){ age = new int(a); } ~TEST(){ if(age != nullptr){ delete age; age = nullptr; } } int *age = nullptr; }; int main(){ TEST a1(10); TEST a2(a1); cout \u003c\u003c *a1.age \u003c\u003c endl; //a1.~TEST(); cout \u003c\u003c *a2.age \u003c\u003c endl; return 0; } 编译器默认给的拷贝构造函数就是只会浅拷贝，想实现深拷贝，需要自己动手。\n5. 类a作为类b的成员 先构造成员类 a， 再构造 b。\n先析构b，再析构成员类a，也就是说析构的顺序与构造的顺序相反。\n6. 静态成员 静态成员：用static修饰的成员变量或函数，也是可以设置public、private等访问权限的。\n特点：类内声明，类外初始化。\n静态成员变量：\n所有实例化后的对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化int test::age = 10; 静态成员函数：\n所有实例化后的对象共享一个函数 静态成员函数只能访问静态成员变量（因为静态成员函数只有一份，这个类可能实例化出来好多对象，如果调用的不是静态成员变量（每个对象都会拷贝出来一个），它根本不知道去访问哪一个对象的变量）。 静态的成员（包括变量和函数）都可以不实例化对象直接进行访问和调用\n#include using namespace std; class test{ public: // 这里如果是private，那么外部就不可以访问了，只能在类中操作 static int a; }; int test::a = 10; int main(){ test a; cout \u003c\u003c test::a \u003c\u003c endl; // private修饰下不允许访问 cout \u003c\u003c a.a \u003c\u003c endl; // private修饰下不允许访问 return 0; } 7. 对象模型和this指针 类中的变量和函数是分开存储的，类通过一些办法将他们组织到一起，构成了一个类。\n变量、函数、静态变量、静态函数四者中，只有变量是属于类的对象上的，其他三个都不属于类的对象上。\n原因：\n每一个非静态成员函数其实只有一份。各个实例化了的对象调用自己的这个成员函数时，this指针指向该对象，该成员函数通过 this 指针区分是哪个对象调用了它。可以使用 *this返回对象自己。\n#include using namespace std; class test{ public: test(int a){ age = a; } test \u0026add( int a){ // 注意这里 返回是引用 否则返回的就是原始对象本身了 就是原始对象的一个拷贝，就不能满足链式编程的思想 age += a; return *this; } int age; }; int main(){ test a(10); // 这也是链式编程的思想 a.add(3).add(3); cout \u003c\u003c a.age \u003c\u003c endl; // 输出16 return 0; } 一个空的指针也是可以访问类内函数的，但是要注意，此时类内的this指针也是null，所以，如果用空指针调用类内函数，并且类内函数访问了成员变量（完整形式是 this -\u003e 成员变量），就相当于对null进行访问，程序就会出错。 8. const修饰成员函数 常函数：\n是用const修饰的成员函数 常函数不可修改成员属性（除了mutable的属性） 常对象：\n使用const修饰一个实例化的对象，即为常对象 常对象只能调用常函数 为什么const修饰过的函数（常函数）不能修改成员属性？\n修改成员属性实际上是this下的属性，this指针实际上是指针常量(* const )，一旦实例化了一个对象，this指针就指向了它，且不能再更改了。 在成员函数参数列表后边加上const进行修饰，相当于说：在本函数中，this指向的空间也是const的了，也不允许通过this进行修改了。 #include using namespace std; class test{ public: // this 指针相当于指针常量 test * const this // 函数后加了一个const 修饰的其实是this所指的空间 即 const test * const this // 即加了const，在本函数内 this所指的空间 不允许通过this进行改变了 void fuc1() const { this -\u003e a = 10; // 编译器报错 } int a; }; int main(){ test p; p.fuc1(); return 0; } 为什么常对象只允许调用常函数？\n可以这样理解：常对象本身的意思就是只读，如果调用了一个非常函数，万一这个函数对自己的属性进行了修改怎么办？所以，直接在根本上拒绝这样危险的操作，直接限定常对象只允许调用常函数，因为常函数肯定修改不了自己的属性。 9. 重载运算符 9.1 基本运算符重载 以加法为例，就相当于自己在类里边写了一个做加法的函数，但是函数名统一成operator +了，可以通过这个函数名像普通成员函数那样调用a.operator+( b )，但是，也可以简写为 a + b。\n运算符重载，也可以发生函数重载，比如加法运算，可以是两个类做相加，也可以是一个类和一个整数相加。 9.2 左移运算符重载 作用：输出自定义的数据类型eg: cout \u003c\u003c class\n如果在类内定义左移重载运算符的话类本身就默认作为左操作数了，那么cout就只能在右边，比如class \u003c\u003c cout，可见这是不符合预期的，所以左移运算符的重载，一般不写在类中，都写成全局函数的形式。 为了满足链式编程，返回值也要是输出流的引用。 inline ostream \u0026operator\u003c\u003c (ostream \u0026out, test \u0026s){ out \u003c\u003c s.a; return out; } 此时，重载运算符的函数是定义在全局函数中的，是如法访问类中的private成员的，还需要进行友元申明，给它访问权限。 9.3 递增递减运算符重载 重载运算符函数中空参数，可以理解为将this作为右操作数。 后置++运算符重载，需要一个int占位，来区分前置和后置的重载。 要注意前置和后置两种重载的返回类型。 class test{ friend inline ostream\u0026 operator\u003c\u003c (ostream \u0026out, test a); public: test(){ age = 10; } // 重载前置++ 必须要返回引用 test\u0026 operator++(){ // 没有占位的就当作this是右操作数 age++; return *this; } // 重载后置++，不用返回引用，因为返回去可能就看一下值是多少，this本身还是做了+1的。 test operator++ (int){ // this本身作为左值了， 右侧搞一个int来占位 test tmp = *this; age++; return tmp; } private: int age; }; inline ostream\u0026 operator\u003c\u003c (ostream \u0026out, test a){ out \u003c\u003c a.age; return out; } 9.4 赋值运算符重载 c++编译器至少添加4个默认的函数。\n默认构造函数、析构函数、拷贝构造函数、赋值运算符（对属性进行浅拷贝）。\n要注意如果有堆区数据的话，在重载赋值运算符的时候需要对堆取数据进行深拷贝。\n要注意a = b = c的情况，也就是赋值运算符的重载函数需要有一个返回值引用。\ntest\u0026 operator= (test \u0026a) { if(age != nullptr){ delete age; age = nullptr; } // 深拷贝 age = new int(*a.age); return *this; // 连续赋值 } 9.5 关系运算符重载 没什么特殊的\n9.6 函数调用运算符重载 函数调用运算符：就是小括号（），也可以重载。\n由于重载后使用的方式非常像函数的调用，因此也称仿函数（STL中使用的较多）。\n仿函数没有固定写法，非常灵活。\n10. 转换函数 目的：将一个类转换成其他类型。\n转换函数通常不会修改自身的数据，一般要加上const修饰。\nclass person{ public: operator int() const { return int(1.0); } // 不用写返回类型，因为函数名就是返回的类型。 // 一般都加上const修饰 }; person f; int a = 4 + f; // 尝试将f转换为int型。调用了类中的重载函数。 // int a = f + 4; // 这句话则是尝试将4转换成person的类型，需要用到转换构造函数。 11.转换构造函数 真实名字叫non-explicit-one-argument-constructor\n",
  "wordCount" : "3982",
  "inLanguage": "zh",
  "datePublished": "2021-02-17T14:56:45+08:00",
  "dateModified": "2021-02-17T14:56:45+08:00",
  "author":{
    "@type": "Person",
    "name": "Clay"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.ClayHex.com/posts/2021/02/cpp-class/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Clay's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.ClayHex.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.ClayHex.com/" accesskey="h" title="Clay&#39;s Blog (Alt + H)">
                <img src="https://www.ClayHex.com/img/avatar.jpg" alt="" aria-label="logo"
                    height="35">Clay&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch">
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.ClayHex.com/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://www.ClayHex.com/" title="🏡 主页">
                    <span>🏡 主页</span>
                </a>
            </li>
            <li>
                <a href="https://www.ClayHex.com/posts" title="📒 记录">
                    <span>📒 记录</span>
                </a>
            </li>
            <li>
                <a href="https://www.ClayHex.com/tags" title="📛 标签">
                    <span>📛 标签</span>
                </a>
            </li>
            <li>
                <a href="https://www.ClayHex.com/archives/" title="📁 归档">
                    <span>📁 归档</span>
                </a>
            </li>
            <li>
                <a href="https://www.ClayHex.com/about" title="📖 关于">
                    <span>📖 关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.ClayHex.com/">主页</a>&nbsp;»&nbsp;<a href="https://www.ClayHex.com/posts/">📒 记录</a>&nbsp;»&nbsp;<a href="https://www.ClayHex.com/posts/learn/">📚 学习</a></div>
    <h1 class="post-title entry-hint-parent">
      C&#43;&#43;学习记录(5) 类
    </h1>
    <div class="post-description">
      c&#43;&#43;中的类
    </div>
    <div class="post-meta"><span class="parent-post-meta"><span id="post_meta_style_1">
        <span class="fa fa-calendar"></span>
        <span>2021-02-17
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>3982字
            &nbsp;&nbsp;
        </span>
    </span><span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>Clay
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://www.ClayHex.com/tags/c&#43;&#43;/" style="color: var(--secondary)!important;">C&#43;&#43;</a>
            </span>
        </span>
    </span>
</span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#0-%e7%b1%bb%e7%9a%844%e4%b8%aa%e9%bb%98%e8%ae%a4%e5%87%bd%e6%95%b0" aria-label="0. 类的4个默认函数">0. 类的4个默认函数</a></li>
                    <li>
                        <a href="#1-%e7%b1%bb%e7%9a%84%e8%ae%bf%e9%97%ae%e8%af%b4%e6%98%8e%e7%ac%a6%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90" aria-label="1. 类的访问说明符（访问权限）">1. 类的访问说明符（访问权限）</a></li>
                    <li>
                        <a href="#2-%e5%8f%8b%e5%85%83" aria-label="2. 友元">2. 友元</a></li>
                    <li>
                        <a href="#3-%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0" aria-label="3. 内联函数">3. 内联函数</a></li>
                    <li>
                        <a href="#4-%e6%b7%b1%e6%8b%b7%e8%b4%9d%e4%b8%8e%e6%b5%85%e6%8b%b7%e8%b4%9d" aria-label="4. 深拷贝与浅拷贝">4. 深拷贝与浅拷贝</a></li>
                    <li>
                        <a href="#5-%e7%b1%bba%e4%bd%9c%e4%b8%ba%e7%b1%bbb%e7%9a%84%e6%88%90%e5%91%98" aria-label="5. 类a作为类b的成员">5. 类a作为类b的成员</a></li>
                    <li>
                        <a href="#6-%e9%9d%99%e6%80%81%e6%88%90%e5%91%98" aria-label="6. 静态成员">6. 静态成员</a></li>
                    <li>
                        <a href="#7-%e5%af%b9%e8%b1%a1%e6%a8%a1%e5%9e%8b%e5%92%8cthis%e6%8c%87%e9%92%88" aria-label="7. 对象模型和this指针">7. 对象模型和this指针</a></li>
                    <li>
                        <a href="#8-const%e4%bf%ae%e9%a5%b0%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" aria-label="8. const修饰成员函数">8. const修饰成员函数</a></li>
                    <li>
                        <a href="#9-%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="9. 重载运算符">9. 重载运算符</a><ul>
                            
                    <li>
                        <a href="#91-%e5%9f%ba%e6%9c%ac%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" aria-label="9.1 基本运算符重载">9.1 基本运算符重载</a></li>
                    <li>
                        <a href="#92-%e5%b7%a6%e7%a7%bb%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" aria-label="9.2 左移运算符重载">9.2 左移运算符重载</a></li>
                    <li>
                        <a href="#93-%e9%80%92%e5%a2%9e%e9%80%92%e5%87%8f%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" aria-label="9.3 递增递减运算符重载">9.3 递增递减运算符重载</a></li>
                    <li>
                        <a href="#94-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" aria-label="9.4 赋值运算符重载">9.4 赋值运算符重载</a></li>
                    <li>
                        <a href="#95-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" aria-label="9.5 关系运算符重载">9.5 关系运算符重载</a></li>
                    <li>
                        <a href="#96-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" aria-label="9.6 函数调用运算符重载">9.6 函数调用运算符重载</a></li></ul>
                    </li>
                    <li>
                        <a href="#10-%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0" aria-label="10. 转换函数">10. 转换函数</a></li>
                    <li>
                        <a href="#11%e8%bd%ac%e6%8d%a2%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" aria-label="11.转换构造函数">11.转换构造函数</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h1 id="0-类的4个默认函数">0. 类的4个默认函数<a hidden class="anchor" aria-hidden="true" href="#0-类的4个默认函数">#</a></h1>
<p>4个函数：构造函数、析构函数、拷贝构造函数、赋值号重载函数。<br>
在定义类时，如果没有自定义这些函数，编译器会提供默认的函数，在默认的函数中，构造函数、析构函数默认空实现，拷贝构造函数、赋值号重载函数默认是浅拷贝。</p>
<p>拷贝构造函数作用：</p>
<ul>
<li>参数是一个同类型的对象，直接拷贝这个参数的所有属性，注意，这个拷贝默认是浅拷贝，需要深拷贝的话需要重载拷贝构造函数。</li>
</ul>
<p>【注】</p>
<ul>
<li>如果在实例化一个对象的时候，后边加了一个空括号，编译器会认为这是一个函数声明而不是实例化，所以，如果一个类的构造函数没有参数的时候，实例化时不用附加空括号.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Person</span> <span class="nf">a</span><span class="p">();</span>  <span class="c1">// 这样会认为是一个函数声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Person</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 应该这样
</span></span></span></code></pre></div><ul>
<li>
<p>不要用拷贝构造函数去初始化一个匿名对象，否则从编译器会认为这是重定义。</p>
</li>
<li>
<p>可以像这样给构造函数传参<code>Person aaa = 10;</code> 隐式转换法。</p>
</li>
<li>
<p>如果没有自定义构造函数的话，C++会自动分配<strong>空的构造函数</strong>和 <strong>只会浅拷贝的拷贝构造函数</strong></p>
</li>
</ul>
<h1 id="1-类的访问说明符访问权限">1. 类的访问说明符（访问权限）<a hidden class="anchor" aria-hidden="true" href="#1-类的访问说明符访问权限">#</a></h1>
<ul>
<li>public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；</li>
<li>protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；</li>
<li>private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象访问。</li>
</ul>
<hr>
<ul>
<li>三者都允许友元访问。</li>
<li>protected和public的区别就在于类的类外可不可以调用。</li>
<li>protected和private的区别就在于子类是否可以访问，private权限给的最小，子类都不可以访问。</li>
</ul>
<hr>
<p>总结：按照类的对象是否可以访问，可以将后两个分成一类，按照子类是否可以访问，可以将前两个分成一类。</p>
<h1 id="2-友元">2. 友元<a hidden class="anchor" aria-hidden="true" href="#2-友元">#</a></h1>
<p>对于不完全开放的protected和private中的成员，类 可以为友元函数（类）提供单独的访问权限。</p>
<ul>
<li>全局函数可以做友元</li>
<li>类可以做友元</li>
<li>类的成员函数可以做友元</li>
</ul>
<hr>
<p>友元函数的<strong>声明</strong>必须在类内，最好是在类的开始位置。但是友元函数的<strong>定义</strong>或者说<strong>实现</strong>即可在在类内，也可以在类外。</p>
<blockquote>
<p><strong>友元的声明仅仅指定了访问权限，而非通常意义上的函数声明，如果我们希望类的用户可以调用某个友元函数，那么我们就必须在友元声明之外，再专门对该函数进行一次声明（提供给用户）</strong>。</p>
<hr>
<p>为了方便，通常把友元的声明与类本身放置在同一个头文件中（类的外部单独对该函数声明，以备外部调用方便）。</p>
</blockquote>
<ul>
<li>类内进行友元函数定义，相当于定义了一个<strong>全局函数</strong>。</li>
</ul>
<p>参考代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">test</span><span class="p">(){</span>   <span class="c1">// 友元函数声明 + 定义，如果不加friend的话，相当于一个普通的成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">123</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//  test函数的定义在Person类的内部，现在想使用它，必须单独进行声明，告诉编译器，我已经定义了test函数，直接调用没问题。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">test</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="3-内联函数">3. 内联函数<a hidden class="anchor" aria-hidden="true" href="#3-内联函数">#</a></h1>
<p>一般来说，内联机制用于优化规模较小、流程简单、频繁调用的函数。<br>
在编译时，直接把内联函数替换到调用它的地方，这样就省去了运行时调用函数的开销。</p>
<ul>
<li>类内定义的成员函数默认都<strong>是inline</strong>的。</li>
<li>类外定义的成员函数默认都<strong>不是inline</strong>的，想使用的话，可以加上inline说明。同时，需要把类的定义和该类外定义的成员函数 放在同一个文件中，否则编译时找不到内联函数。</li>
</ul>
<h1 id="4-深拷贝与浅拷贝">4. 深拷贝与浅拷贝<a hidden class="anchor" aria-hidden="true" href="#4-深拷贝与浅拷贝">#</a></h1>
<p>如果没有自定义构造函数的话，C++会自动分配<strong>空的构造函数</strong>和 <strong>只会浅拷贝的拷贝构造函数</strong></p>
<p>在执行拷贝构造函数的时候，如果第一个对象 a1 在堆上开了一个指针 p 指向的地址是0x0011，a2使用a1进行初始化（使用拷贝构造函数复制a1的值）。所有属性完全复制，所以a2中的p所指的地址也是0x0011，并没有重新开辟一个堆的空间。所以如果a1先被释放了的话，a2再使用这个指针进行操作，就会产生异常了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TEST</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">TEST</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">~</span><span class="n">TEST</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">age</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="k">delete</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">age</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="n">age</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">TEST</span> <span class="n">a1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">TEST</span> <span class="n">a2</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a1</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="c1">//a1.~TEST();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a2</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>编译器默认给的拷贝构造函数就是只会浅拷贝，想实现深拷贝，需要自己动手。</p>
<h1 id="5-类a作为类b的成员">5. 类a作为类b的成员<a hidden class="anchor" aria-hidden="true" href="#5-类a作为类b的成员">#</a></h1>
<p>先构造成员类 a， 再构造 b。<br>
先析构b，再析构成员类a，也就是说析构的顺序与构造的顺序相反。</p>
<h1 id="6-静态成员">6. 静态成员<a hidden class="anchor" aria-hidden="true" href="#6-静态成员">#</a></h1>
<p>静态成员：用static修饰的成员变量或函数，也是可以设置public、private等访问权限的。<br>
特点：类内声明，类外初始化。<br>
静态成员变量：</p>
<ul>
<li>所有实例化后的对象共享一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化<code>int test::age = 10;</code></li>
</ul>
<p>静态成员函数：</p>
<ul>
<li>所有实例化后的对象共享一个函数</li>
<li>静态成员函数只能访问静态成员变量（因为静态成员函数只有一份，这个类可能实例化出来好多对象，如果调用的不是静态成员变量（每个对象都会拷贝出来一个），它根本不知道去访问哪一个对象的变量）。</li>
</ul>
<hr>
<p>静态的成员（包括变量和函数）都可以不实例化对象直接进行访问和调用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>   <span class="c1">// 这里如果是private，那么外部就不可以访问了，只能在类中操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">test</span><span class="o">::</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="n">test</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test</span><span class="o">::</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// private修饰下不允许访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// private修饰下不允许访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="7-对象模型和this指针">7. 对象模型和this指针<a hidden class="anchor" aria-hidden="true" href="#7-对象模型和this指针">#</a></h1>
<p>类中的变量和函数是分开存储的，类通过一些办法将他们组织到一起，构成了一个类。</p>
<p>变量、函数、静态变量、静态函数四者中，只有变量是属于类的对象上的，其他三个都不属于类的对象上。<br>
原因：<br>
每一个<strong>非静态成员函数</strong>其实只有一份。各个实例化了的对象调用自己的这个成员函数时，this指针指向该对象，该成员函数通过 this 指针区分是哪个对象调用了它。可以使用 <code>*this</code>返回对象自己。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">age</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">test</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">){</span>   <span class="c1">// 注意这里 返回是引用  否则返回的就是原始对象本身了  就是原始对象的一个拷贝，就不能满足链式编程的思想
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">age</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">test</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 这也是链式编程的思想
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">// 输出16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>一个空的指针也是可以访问类内函数的，但是要注意，此时类内的this指针也是null，所以，如果用空指针调用类内函数，并且类内函数访问了成员变量（完整形式是 this -&gt; 成员变量），就相当于对null进行访问，程序就会出错。</li>
</ul>
<h1 id="8-const修饰成员函数">8. const修饰成员函数<a hidden class="anchor" aria-hidden="true" href="#8-const修饰成员函数">#</a></h1>
<p>常函数：</p>
<ul>
<li>是用const修饰的成员函数</li>
<li>常函数不可修改成员属性（除了mutable的属性）</li>
</ul>
<p>常对象：</p>
<ul>
<li>使用const修饰一个实例化的对象，即为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p>为什么const修饰过的函数（常函数）不能修改成员属性？</p>
<blockquote>
<ul>
<li>修改成员属性实际上是this下的属性，this指针实际上是<strong>指针常量(* const )</strong>，一旦实例化了一个对象，this指针就指向了它，且不能再更改了。</li>
<li>在成员函数参数列表后边加上const进行修饰，相当于说：在本函数中，this指向的空间也是const的了，也不允许通过this进行修改了。</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// this 指针相当于指针常量 test * const this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 函数后加了一个const 修饰的其实是this所指的空间  即 const test * const this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 即加了const，在本函数内 this所指的空间 不允许通过this进行改变了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">void</span> <span class="n">fuc1</span><span class="p">()</span> <span class="k">const</span>  
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// 编译器报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">test</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">p</span><span class="p">.</span><span class="n">fuc1</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为什么常对象只允许调用常函数？</p>
<blockquote>
<ul>
<li>可以这样理解：常对象本身的意思就是只读，如果调用了一个非常函数，万一这个函数对自己的属性进行了修改怎么办？所以，直接在根本上拒绝这样危险的操作，直接限定常对象只允许调用常函数，因为常函数肯定修改不了自己的属性。</li>
</ul>
</blockquote>
<h1 id="9-重载运算符">9. 重载运算符<a hidden class="anchor" aria-hidden="true" href="#9-重载运算符">#</a></h1>
<h2 id="91-基本运算符重载">9.1 基本运算符重载<a hidden class="anchor" aria-hidden="true" href="#91-基本运算符重载">#</a></h2>
<p>以加法为例，就相当于自己在类里边写了一个做加法的函数，但是函数名统一成<code>operator +</code>了，可以通过这个函数名像普通成员函数那样调用<code>a.operator+( b )</code>，但是，也可以简写为 <code>a + b</code>。</p>
<ul>
<li>运算符重载，也可以发生函数重载，比如加法运算，可以是两个类做相加，也可以是一个类和一个整数相加。</li>
</ul>
<h2 id="92-左移运算符重载">9.2 左移运算符重载<a hidden class="anchor" aria-hidden="true" href="#92-左移运算符重载">#</a></h2>
<p>作用：输出自定义的数据类型<code>eg:  cout &lt;&lt; class</code></p>
<ul>
<li>如果在类内定义左移重载运算符的话类本身就默认作为<strong>左操作数</strong>了，那么cout就只能在右边，比如<code>class &lt;&lt; cout</code>，可见这是不符合预期的，所以左移运算符的重载，一般不写在类中，都写成全局函数的形式。</li>
<li>为了满足链式编程，返回值也要是输出流的引用。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">test</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>此时，重载运算符的函数是定义在全局函数中的，是如法访问类中的private成员的，还需要进行友元申明，给它访问权限。</li>
</ul>
<h2 id="93-递增递减运算符重载">9.3 递增递减运算符重载<a hidden class="anchor" aria-hidden="true" href="#93-递增递减运算符重载">#</a></h2>
<ul>
<li>重载运算符函数中空参数，可以理解为将this作为右操作数。</li>
<li>后置++运算符重载，需要一个int占位，来区分前置和后置的重载。</li>
<li>要注意前置和后置两种重载的返回类型。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">test</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重载前置++ 必须要返回引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">test</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 没有占位的就当作this是右操作数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">age</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重载后置++，不用返回引用，因为返回去可能就看一下值是多少，this本身还是做了+1的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">test</span> <span class="k">operator</span><span class="o">++</span> <span class="p">(</span><span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// this本身作为左值了， 右侧搞一个int来占位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">test</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">age</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">test</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="94-赋值运算符重载">9.4 赋值运算符重载<a hidden class="anchor" aria-hidden="true" href="#94-赋值运算符重载">#</a></h2>
<p>c++编译器至少添加4个默认的函数。</p>
<ul>
<li>
<p>默认构造函数、析构函数、拷贝构造函数、赋值运算符（对属性进行浅拷贝）。</p>
</li>
<li>
<p>要注意如果有堆区数据的话，在重载赋值运算符的时候需要对堆取数据进行深拷贝。</p>
</li>
<li>
<p>要注意<code>a = b = c</code>的情况，也就是赋值运算符的重载函数需要有一个返回值引用。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">test</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">test</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">age</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">age</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 深拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="n">age</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>   <span class="c1">// 连续赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span></code></pre></div><h2 id="95-关系运算符重载">9.5 关系运算符重载<a hidden class="anchor" aria-hidden="true" href="#95-关系运算符重载">#</a></h2>
<p>没什么特殊的</p>
<h2 id="96-函数调用运算符重载">9.6 函数调用运算符重载<a hidden class="anchor" aria-hidden="true" href="#96-函数调用运算符重载">#</a></h2>
<p>函数调用运算符：就是小括号（），也可以重载。<br>
由于重载后使用的方式非常像函数的调用，因此也称仿函数（STL中使用的较多）。<br>
仿函数没有固定写法，非常灵活。</p>
<h1 id="10-转换函数">10. 转换函数<a hidden class="anchor" aria-hidden="true" href="#10-转换函数">#</a></h1>
<p>目的：将一个类转换成其他类型。<br>
转换函数通常不会修改自身的数据，一般要加上const修饰。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">int</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 不用写返回类型，因为函数名就是返回的类型。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 一般都加上const修饰
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">person</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// 尝试将f转换为int型。调用了类中的重载函数。
</span></span></span><span class="line"><span class="cl"><span class="c1">// int a = f + 4; // 这句话则是尝试将4转换成person的类型，需要用到转换构造函数。
</span></span></span></code></pre></div><h1 id="11转换构造函数">11.转换构造函数<a hidden class="anchor" aria-hidden="true" href="#11转换构造函数">#</a></h1>
<p>真实名字叫<code>non-explicit-one-argument-constructor</code></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.ClayHex.com/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.ClayHex.com/posts/2021/02/cpp-inheritance/">
    <span class="title">« 上一篇</span>
    <br>
    <span>C&#43;&#43;学习记录(6) 继承</span>
  </a>
  <a class="next" href="https://www.ClayHex.com/posts/2021/02/cpp-reference/">
    <span class="title">下一篇 »</span>
    <br>
    <span>C&#43;&#43;学习记录(4) 引用</span>
  </a>
</nav>

  </footer><script>
    function createGiscusScript(data) {
      const giscusScript = document.createElement('script');
  
      
      Object.entries(data).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  
      
      document.querySelector('article').appendChild(giscusScript);
  
      
      const toggle = document.querySelector('label[for="switch_default"]');
      if (toggle) {
        toggle.addEventListener('click', function () {
          
          const theme = document.body.classList.contains('dark') ? 'transparent_dark' : 'light';
          giscusScript.setAttribute('data-theme', theme);
  
          
          sendMessage({ setConfig: { theme } });
        });
      }
    }
  
    function sendMessage(message) {
      const iframe = document.querySelector('iframe.giscus-frame');
      if (iframe) {
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
    }
  
    document.addEventListener('DOMContentLoaded', function () {
      
      const giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'Clay-Hex/BlogComments',
        'data-repo-id': 'R_kgDOLexoRQ',
        'data-category': 'Announcements',
        'data-category-id': 'DIC_kwDOLexoRc4Cd5Ao',
        'data-mapping': 'pathname',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'top',
        'data-lang': 'zh-CN',
        crossorigin: 'anonymous',
        async: '',
      };
  
      
      giscusAttributes['data-theme'] = document.body.classList.contains('dark')
        ? 'transparent_dark'
        : 'light';
  
      
      createGiscusScript(giscusAttributes);
  
      
      const bodyObserver = new MutationObserver(() => {
        const theme = document.body.classList.contains('dark') ? 'transparent_dark' : 'light';
        sendMessage({ setConfig: { theme } });
      });
  
      bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
    });

    
    
    
    
    
    
    
    
    

    
  </script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://www.ClayHex.com/">Clay&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
