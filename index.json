[{"content":"0. C++ 中的锁 两种最常用的：互斥锁、条件锁，此外还有自旋锁\n1. C++ 中的条件变量 2. 生产者消费者模型 引出虚假唤醒的问题\n3. 虚假唤醒 有多个线程在wait同一个条件变量时，当条件变量发出notify_one的时候，各个线程去竞争锁，此时，只能有一个线程得到锁，但是，其他线程在收到notify_one信号时，线程已经从wait队列换到锁竞争的队列了（不再等待notify的通知了，而是等待其他线程解除对锁的占用），一旦某个线程拿到锁了，就会立刻向下执行代码，但此时，条件可能已经变了，不是预期的条件了。\n解决办法：\n把if改成while，在收到通知消息后循环判断条件是否成立。 传递一个lambda函数给wait函数的第二个参数，该lambda方法返回等待的条件。该方式可以理解为，在收到notify信号后，线程先竞争锁，得到锁后，再检查一下lambda函数的返回值，如果返回值是true，则结束wait状态，继续向下执行。如果返回false，则解锁，继续wait。本质上等价于解决办法1。 ","permalink":"https://Clay-Hex.github.io/posts/2022/11/cpp-conditional-variables-lock/","summary":"0. C++ 中的锁 两种最常用的：互斥锁、条件锁，此外还有自旋锁 1. C++ 中的条件变量 2. 生产者消费者模型 引出虚假唤醒的问题 3. 虚假唤醒 有多个线程在wait同一个条件变量时，当条件变量发出notify_one的时候，各个线程去竞争锁，此时，只能有一个线程得到锁，但是，其他线程在收到notify_on","title":"C++学习记录(15) 条件变量与互斥锁"},{"content":"1. 编译器默认添加的函数 自写类的时候，如果没有显式的写出来构造函数、析构函数、拷贝构造函数、拷贝赋值函数。如果程序中这些函数被需要（被调用），编译器就会默认的创建这些函数。\n默认的构造函数和析构函数都是空实现的。\n默认的拷贝构造函数和拷贝赋值函数都是浅拷贝。\n如果有自己写的一个或者多个构造函数（不管有无参数），那么编译器都不会再添加默认的构造函数。\n2. 如何禁止拷贝构造函数、拷贝赋值函数？ 可以将拷贝构造函数、拷贝赋值函数显式的定义为private。这样可以，但是并不是绝对的安全，因为此时，类的成员函数、友元类、友元函数，依然可以调用这些函数。\n比较好的做法是，将函数声明为private的，同时不对该函数进行定义。\n此后，如果直接调用这两个函数，会在编译期报错。如果用友元或者成员函数调用，会在连接期报错。\n也可以单独写一个unCopyable类，然后base 私有继承unCopyable，base内不用再声明拷贝构造和拷贝赋值，这样的操作，会将错误从连接时期提前至编译时期。\n3. virtual 修饰的析构函数 一个子类对象经由一个父类指针delete时，如果父类的析构函数不是虚函数，那么执行delete后，该子类对象是“部分销毁”的，子类对象内部继承自父类的资源都会被释放掉，但是子类自己独有的资源可能会造成泄漏。\n一个原则是：如果类中没有虚函数，表明该类不想被继承，那么析构函数也不需要弄成虚函数；如果一个类中有至少一个虚函数，表明该类有可能被继承，那么析构函数最好弄成虚函数。\n4. 纯虚函数与纯虚析构函数的区别 一个类，一旦内部有一个纯虚函数,那么该类就是一个抽象类，无法实例化。只能等待被继承。\n纯虚函数与纯虚析构函数的区别在于纯虚函数不需要提供定义，而纯虚析构函数需要具体定义。原因在于：当发生多态时，通过父类指针delete子类对象时，先执行子类的析构函数，再调用父类的析构函数，从下至上逐层析构，那么抽象类的纯虚析构函数，如果没有具体实现，在连接时，就会报错，所以必须要有具体实现。保证继承体系的完整析构过程。\n","permalink":"https://Clay-Hex.github.io/posts/2022/04/cpp-constructors-destructors/","summary":"1. 编译器默认添加的函数 自写类的时候，如果没有显式的写出来构造函数、析构函数、拷贝构造函数、拷贝赋值函数。如果程序中这些函数被需要（被调用），编译器就会默认的创建这些函数。 默认的构造函数和析构函数都是空实现的。 默认的拷贝构造函数和拷贝赋值函数都是浅拷贝。 如果有自己写的一个或者多个构","title":"C++学习记录(14) 构造函数与析构函数"},{"content":"1. 代码 /* * @Brief: 常见排序算法汇总 * @Author: * @Date: 2021-07-01 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; void printArray(int *a, int len){ for(int i = 0; i \u0026lt; len; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } void bubbleSort(int *a, int len){ for(int i = 0; i \u0026lt; len - 1; i++){ for(int j = 0; j \u0026lt; len - i; j++){ if(a[j] \u0026gt; a[j+1]) swap(a[j], a[j+1]); } } } void selectSort(int *a, int len){ for(int i = 0; i \u0026lt; len; i++){ int mi = i; for(int j = i; j \u0026lt; len; j++){ if(a[j] \u0026lt; a[mi]) mi = j; } if(i != mi) swap(a[i], a[mi]); } } void insertionSort(int *a, int len){ for(int i = 0; i \u0026lt; len; i++){ int key = a[i]; int j = i; while(j \u0026gt;= 1 \u0026amp;\u0026amp; a[j - 1] \u0026gt; key) a[j] = a[j-1], j--; a[j] = key; } } void shellSort(int *a, int len){ // cout \u0026lt;\u0026lt; \u0026#34;原始数组\u0026#34; \u0026lt;\u0026lt; endl; // printArray(a, len); for(int d = len / 2; d \u0026gt;= 1; d /= 2){ // 插入排序 for(int i = 0; i \u0026lt; len; i += d){ int key = a[i]; int j = i; while(j \u0026gt;= d \u0026amp;\u0026amp; a[j-d] \u0026gt; key) a[j] = a[j-d], j -= d; a[j] = key; } // cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34; 排序结果\u0026#34; \u0026lt;\u0026lt; endl; // printArray(a, len); } } void quickSort(int *a, int len, int l, int r){ if(l \u0026gt;= r) return ; int x = a[l + (r - l) / 2]; int i = l - 1, j = r + 1; while(i \u0026lt; j){ while(a[++i] \u0026lt; x); while(a[--j] \u0026gt; x); if(i \u0026lt; j) swap(a[i], a[j]); } quickSort(a, len, l, j); quickSort(a, len, j + 1, r); } void mergeSort(int *a, int len, int l, int r){ if(l \u0026gt;= r) return ; int mid = l + (r - l) / 2; mergeSort(a, len, l, mid); mergeSort(a, len, mid + 1, r); int i = l, j = mid + 1, k = 0; int *tmp = new int[r - l + 1]; while(i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r){ if(a[i] \u0026lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } // 处理尾巴 while(i \u0026lt;= mid) tmp[k++] = a[i++]; while(j \u0026lt;= r) tmp[k++] = a[j++]; // 复制回原数组中 for(i = l, k = 0; i \u0026lt;= r; i++, k++) a[i] = tmp[k]; delete tmp; // 回收内存 } // 堆排序 namespace heapSort{ int *heap = nullptr; int ss = 0; // 堆的现有节点数 从下标是1的节点开始存 int n = 0; // 数组长度 void down(int u){ // 小顶堆 int t = u; if(u * 2 \u0026lt;= ss \u0026amp;\u0026amp; heap[u * 2] \u0026lt; heap[t]) t = u * 2; if(u * 2 + 1 \u0026lt;= ss \u0026amp;\u0026amp; heap[u * 2 + 1] \u0026lt; heap[t]) t = u * 2 + 1; if(t != u){ swap(heap[t], heap[u]); down(t); } } void heapSort(int *a, int len){ heap = new int[len + 5]; n = len; for(int i = 0; i \u0026lt; len; i++) heap[++ss] = a[i]; for(int i = n / 2; i ; i--) down(i); for(int i = 0; i \u0026lt; len; i++){ a[i] = heap[1]; heap[1] = heap[ss--]; down(1); } delete heap; } }; int main(){ int a[10] = {8, 4, 2, 5, 7, 3, 1, 9, 0, 6}; int len = 10; //bubbleSort(a, len); //selectSort(a, len); //insertionSort(a, len); //quickSort(a, len, 0, len - 1); //mergeSort(a, len, 0, len - 1); //shellSort(a, len); //heapSort::heapSort(a, len); printArray(a, len); return 0; } 2. 稳定性 稳定排序算法：如果两数相等的话，排序以后先后位置是否会改变，如果不改变，就是稳定的。\n冒泡：相邻两个元素比较，有不等关系才进行交换，两元素相等，不交换。所以是稳定的。 选择：例如 x, x, x-1 三个数，每次选择最小的，第一轮就把第一个x和x-1交换位置了，明显两个x的先后顺序改变了。所以是不稳定的。 插入：从后往前遍历有序序列，找到第一个 \u0026lt;= x 的，如果这个数和x相等，很明显不用交换。所以是稳定的。 希尔：一次插入排序是稳定的，但是希尔用了多次，可能引起相等的数交换位置，所以，是不稳定的。 快排：根据快排的代码就可以知道，当两侧的i和j对应元素相等时，也会交换位置，所以是不稳定的。 归并：可以保证原先在前边的还在前边，后边的还在后边，所以是稳定的。 堆排：不稳定。 基数排序：稳定。\n综上：\n稳定的有：冒泡、插入、归并、基数。 不稳定的有：除上述4个都不稳定。 ","permalink":"https://Clay-Hex.github.io/posts/2021/12/sorting-algorithm-stability/","summary":"1. 代码 /* * @Brief: 常见排序算法汇总 * @Author: * @Date: 2021-07-01 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; void printArray(int *a, int len){ for(int i = 0; i \u0026lt; len; i++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } void bubbleSort(int *a, int len){ for(int i = 0; i \u0026lt; len - 1; i++){ for(int j = 0; j \u0026lt; len - i; j++){ if(a[j] \u0026gt; a[j+1]) swap(a[j], a[j+1]); } } } void selectSort(int *a, int len){ for(int i = 0; i \u0026lt; len; i++){ int mi = i; for(int j = i; j \u0026lt; len; j++){ if(a[j] \u0026lt; a[mi]) mi = j; } if(i != mi) swap(a[i], a[mi]); } } void insertionSort(int *a, int len){ for(int i = 0; i \u0026lt; len;","title":"常见排序算法及稳定性"},{"content":"I\u0026rsquo;m Clay.\n能力不高，水平有限，但TM总想写点什么。\n这是第N次搭博客，希望不会有N+1次。\n2024年3月·上海\n","permalink":"https://Clay-Hex.github.io/about/","summary":"I\u0026rsquo;m Clay. 能力不高，水平有限，但TM总想写点什么。 这是第N次搭博客，希望不会有N+1次。 2024年3月·上海","title":"📖 关于"},{"content":"0. placement new 即 原地构造。 用法：\nint *p = new int(10); // new operator new(p) int(1000); // 在 p 指向的内存上 构造一个int对象，即placement new // 此时 *P 为 1000。 因为是在一个已有的空间上构造对象，所以，空间的释放，就由free或者delete负责了。\n0.1 重载placement new 与后边的 3 ：operator new的重载无异，就是可以多增加几个函数，但是，第一个参数必须是std::size_t 类型，这个参数接收的是 new 后边类型的大小，不用显式传参，默认会传递。 重载示例：\n#include \u0026lt;iostream\u0026gt; using std::cout, std::endl; class base{ public: base(){ cout \u0026lt;\u0026lt; \u0026#34;ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~base(){ cout \u0026lt;\u0026lt; \u0026#34;dtor\u0026#34; \u0026lt;\u0026lt; endl; } // 标准库中的 placement new, 这里什么都没做，只是返回原来的指针。 void * operator new(std::size_t size, void *p){ cout \u0026lt;\u0026lt; \u0026#34;std placement new\u0026#34; \u0026lt;\u0026lt; endl; return p; } //重载 placement new，附加了一个参数 a，参数size会默认传递，不用显式传参。 void * operator new(std::size_t size, int a){ cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return malloc(size); } void * operator new(std::size_t size){ cout \u0026lt;\u0026lt; \u0026#34;new diy\u0026#34; \u0026lt;\u0026lt; endl; return malloc(size); } void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete diy\u0026#34; \u0026lt;\u0026lt; endl; free(p); } private: int a, b, c; }; int main(){ base p; new(\u0026amp;p) base; new(4) base; return 0; } 运行结果：\nctor // 对象默认的构造函数输出的 std placement new // 默认placement new 输出的 ctor // 默认placement new 输出的 a = 4 // 重载的placement new 输出的 ctor // 重载的placement new 输出的 dtor // 析构 1. new operator 一般情况下，我们使用的new都是new operator。 用法：\nint *p = new int(3); 其实底层有两个过程： 第一个过程：开辟空间 第二个过程：构造对象\n2. delete operator delete operator就是平时常用的delete，与new 搭配成对使用。 用法：\nint *p = new int; delete p; 3. operator new 是全局的库函数。\n用法：\nvoid* operator new(size_t size); 其实，operator new底层调用的是malloc（调用形式也挺像的，传入一个开辟的Byte数，返回一个void *）。\n注意，operator new 支持重载！当然了，如果重载了，那就要重载对应的operator delete 4. operator delete 是全局的库函数，与operator new搭配使用。\n用法：\nint *p = new int; operator delete(p); 底层调用的是free。\n支持重载。 5. new 做了哪些事情？ new 操作可以大致的认为包含了两个过程： 第一个过程：开辟相应的空间（使用operator new）。 第二个过程：在刚开辟的空间内构造一个对象（placement new）。\n模拟new操作。\nint *p = static_cast\u0026lt;int*\u0026gt;( operator new(sizeof(int)) ); // new operator 开辟空间 new(p) int(100); // placement new 在p指向的内存上构造一个对象 上边说到operator new和operator delete支持重载，重载可以为我们自己的类类型定制化的分配内存。 只需要在类内重载operator new和operator delete。\n编译器遇到new和delete时，首先看对应的类类型中是否有重载的operator new和operator delete，如果有，则优先调用重载的版本去分配内存，然后再原地构造。如果没有重载版本，就调用全局的库函数。\n如果一个类内有重载的operator new和operator delete，会优先调用重载版本，代码如下：\n#include \u0026lt;iostream\u0026gt; using std::cout, std::endl; class base{ public: base(){ cout \u0026lt;\u0026lt; \u0026#34;ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~base(){ cout \u0026lt;\u0026lt; \u0026#34;dtor\u0026#34; \u0026lt;\u0026lt; endl; } void * operator new(std::size_t size){ cout \u0026lt;\u0026lt; \u0026#34;new diy\u0026#34; \u0026lt;\u0026lt; endl; void *resPtr = malloc(size); return resPtr; } void operator delete(void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete diy\u0026#34; \u0026lt;\u0026lt; endl; free(p); } private: int a, b, c; }; int main(){ base *p = new base; delete p; return 0; } 运行结果：\nnew diy ctor dtor delete diy 也可以显式的使用全局的库函数来new一个对象出来，把main函数中的new和delete换成全局的库函数，如下：\nbase *p = ::new base; ::delete p; 运行结果：\nctor dtor 显式的调用了全局的库函数，而没有调用类类型重载的版本。\n当然，如果不在类内进行重载，在全局进行重载，也是可以的。\n这个两个函数，在类内重载，必须是静态的，即有static修饰，因为调用这两个方法时，对象还没创建（调用new时）或者已经析构（调用delete时），this指针此时是无效的，再想去通过this调用一个方法，这是不可能的，所以必须是静态的。\n上边的代码中，没有加static修饰，也可以完成操作，是因为编译器替我们加上了static。\n6. array new 与 array delete int *p = new int[10]; delete[] p; array new即是用new申请一个数组空间，此时 p 指向第一个元素的起始位置，释放时必须使用对应的array delete，也就是delete[ ]。\n对于基本数据类型来说，如果把上边的delete[] p 改成 delete p，没什么问题，不会造成内存泄漏。但如果是自定义的类，并且类中有在堆上开辟内存空间的话，就会造成内存泄漏。 因为delete p 只会调用一个元素的析构函数，然后释放对应的空间，数组中的其余元素，虽然元素（类对象）本身的空间释放了，但是该对象原本来堆上开辟的内存空间，并没有释放掉（因为他的析构函数没有被调用），由此造成内存泄漏。\n与上边的new 和 delete一样，array版本的new和delete也支持重载。 示例如下：\n#include \u0026lt;iostream\u0026gt; using std::cout, std::endl; class base{ public: base(){ cout \u0026lt;\u0026lt; \u0026#34;ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~base(){ cout \u0026lt;\u0026lt; \u0026#34;dtor\u0026#34; \u0026lt;\u0026lt; endl; } void * operator new[](std::size_t size){ cout \u0026lt;\u0026lt; \u0026#34;new[] diy\u0026#34; \u0026lt;\u0026lt; endl; void *resPtr = malloc(size); return resPtr; } void operator delete[](void *p){ cout \u0026lt;\u0026lt; \u0026#34;delete[] diy\u0026#34; \u0026lt;\u0026lt; endl; free(p); } private: int a, b, c; }; int main(){ base *p = new base[2]; delete[] p; return 0; } 运行结果：\nnew[] diy ctor ctor dtor dtor delete[] diy 7. delete[ ] 为什么能够释放数组？ 在使用new创建一个数组时，所开辟的实际内存大小比要申请的大小要大一些，在申请到的数组空间的上下都有额外的开销，来记录这块数组空间的相关信息，其中就包括数组空间的长度，每个元素的长度。所以 delete[ ] 可以顺利的知道数组的长度，并且可以成功的调用所有元素的析构函数。\n","permalink":"https://Clay-Hex.github.io/posts/2021/08/cpp-new-and-delete/","summary":"0. placement new 即 原地构造。 用法： int *p = new int(10); // new operator new(p) int(1000); // 在 p 指向的内存上 构造一个int对象，即placement new // 此时 *P 为 1000。 因为是在一个已有的空间上构造对象，所以，空间的释放，就由free或者delete负责了。 0.1 重载placement new 与后边的 3 ：operator new的重载无","title":"C++学习记录(13) new与delete"},{"content":" 0. 必要性 C语言中的类型转换，没有安全检查，安全性需要程序猿来保证，C++提供了4种类型转换的方法，在一定程度上保证转换的安全性。\n重点是 dynamic_cast\n1. const_cast 仅用于去除类型的const属性，也是四种类型转换中，唯一可以去掉const限制的方法。\n只能转换 指针、引用、this（在类内的时候用）。 2. static_cast 隐式转换能转的，它都能转，但是也有例外（父类指针 转 子类指针）。\n低风险的都可以转：\n整数与浮点数 整数与字符 void指针转其他类型指针 转换运算符（类内必须提供转换运算符，eg : operator int() { }） 高风险的不允许转：\n整数与指针 （eg：int *p = static_cast\u0026lt;int *\u0026gt; (a);） 注意：父类转子类，是不安全的，因为转换后的子类指针有可能越界访问资源。隐式转换中，这种转换是不允许的，但是static_cast可以做这种向下转换，但是，转换后的使用安全，需要程序猿来保证。 这种向下转换的不安全，可以使用dynamic_cast来保证。\n3. dynamic_cast 用于 具有多态类类型的向下转换时，必须使用。 在转换过程中，如果dynamic_cast发现这种转换不安全，会返回null，转换成功会返回转换后的指针。\n那么，它如何发现父类转子类是不安全的？ 因为它内部使用了RTTI技术，运行时类型识别。RTTI依赖于虚函数表，虚函数表上边有一个type_info的指针，指向了这个类的继承链。 所有，dynamic_cast 需要转换的类型有虚函数，才会检测安全性。\n因为RTTI有开销，所以，除非必要，否则不会使用dynamic_cast 总结：\n基类必须要有虚函数（使用了RTTI，RTTI依赖虚函数表） 运行时类型识别，转换不成功会返回NULL RTTI有额外的开销，一般情况下不使用它做类型转换。 4. interpret_cast 与C语言中的强制类型转换几乎无异。 可以用于各种高危险的类型转换. 不存在类型检查。\n","permalink":"https://Clay-Hex.github.io/posts/2021/08/cpp-type-conversion/","summary":"0. 必要性 C语言中的类型转换，没有安全检查，安全性需要程序猿来保证，C++提供了4种类型转换的方法，在一定程度上保证转换的安全性。 重点是 dynamic_cast 1. const_cast 仅用于去除类型的const属性，也是四种类型转换中，唯一可以去掉const限制的方法。 只能转换 指针、引用、this（在类内的时候用）。 2. static_cast 隐","title":"C++学习记录(12) 类型转换"},{"content":"1. 什么是智能指针 简而言之，为了更安全的使用指针。 实现方式简单来说，就是用一个模板类把一般的指针包装起来。用这个类来维护内部指针的释放操作。 std中有四种智能指针。\nauto_ptr（已弃用） unique_ptr shared_ptr weak_ptr 2. auto_ptr 比较简单的智能指针，实现逻辑如下代码。 实现的原则是：内存空间只能由一个指针所拥有。 存在的问题：拷贝和赋值后，原对象内部的指针会为空，有风险。\ntemplate\u0026lt;class T\u0026gt; class autoPtr{ public: autoPtr(T *a):m_ptr(a){ } ~autoPtr(){ if(m_ptr){ delete m_ptr; m_ptr = nullptr; } } // 拷贝构造 权限转移 autoPtr(autoPtr\u0026lt;T\u0026gt; \u0026amp;a):m_ptr(a.m_ptr) { a.m_ptr = nullptr; } // 赋值 权限转移 autoPtr\u0026amp; operator= (autoPtr\u0026lt;T\u0026gt; \u0026amp;a){ if(this != \u0026amp;a){ if(m_ptr) delete m_ptr; m_ptr = a.m_ptr; a.m_ptr = nullptr; } return *this; } T* operator-\u0026gt;(){ return m_ptr; } T\u0026amp; operator* (){ return *m_ptr; } private: T *m_ptr; }; 3. unique_ptr 是对auto_ptr的改进，实现逻辑如下代码。 实现的原则是：内存空间只能由一个指针所拥有，但是禁止了拷贝和赋值。 在C++中unique_ptr的进制拷贝有一个特例，如果一个unique_ptr是将亡值的话，是允许的，比如unique_ptr作为函数的返回值时，是允许的。\n// uniquePtr 对于autoPtr来说 禁止了拷贝和赋值 template\u0026lt;class T\u0026gt; class uniquePtr{ public: uniquePtr(const T*a):m_ptr(a) { }; ~uniquePtr(){ if(m_ptr) delete m_ptr; } T\u0026amp; operator *(){ return *m_ptr; } T* operator-\u0026gt;(){ return m_ptr; } T* get(){ return m_ptr; } private: T *m_ptr; // 禁止拷贝和赋值 uniquePtr(const uniquePtr\u0026lt;T\u0026gt; \u0026amp;a) { }; uniquePtr\u0026lt;T\u0026gt; \u0026amp; operator = (const uniquePtr\u0026lt;T\u0026gt; \u0026amp;a) { }; }; unique_ptr禁止了拷贝，那么如何把unique_ptr作为参数传递呢？\n法1：使用指针或者引用 void func(unique_ptr\u0026lt;int\u0026gt; \u0026amp;a){ } *法2： 暂时转移内存的所有权，函数返回时，再把所有权交回来。\nunique_ptr\u0026lt;int\u0026gt; func2(unique_ptr\u0026lt;int\u0026gt; a){ cout \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; return a; } int main() { unique_ptr\u0026lt;int\u0026gt; a(new int(6)); // 暂时释放所有权 a = func2(unique_ptr\u0026lt;int\u0026gt;(a.release())); return 0; } 法3：move语义 void func1(unique_ptr\u0026lt;int\u0026gt; a) { cout \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; } int main() { unique_ptr\u0026lt;int\u0026gt; a(new int(6)); func1(std::move(a)); return 0; } 4. shared_ptr 实现逻辑如下代码。 实现的原则是：内存空间可以由多个指针所拥有，但是要控制内存释放的时机，这个时机由“引用计数”来实现。 存在为问题：会存在循环引用问题，导致内存无法正常释放。\ntemplate\u0026lt;class T\u0026gt; class sharedPtr{ public: sharedPtr(T *a):m_ptr(a), m_count(new int(1)) { }; ~sharedPtr(){ if(--(*m_count) == 0){ delete m_ptr; delete m_count; m_ptr = nullptr; m_count = nullptr; } } T\u0026amp; operator *(){ return *m_ptr; } T* operator-\u0026gt;(){ return m_ptr; } // 拷贝构造 sharedPtr(const sharedPtr\u0026lt;T\u0026gt; \u0026amp;a):m_ptr(a.m_ptr),m_count(a.m_count) { ++(*m_count); } // 赋值函数 sharedPtr\u0026lt;T\u0026gt; \u0026amp; operator=(const sharedPtr\u0026lt;T\u0026gt; \u0026amp;a){ if(m_ptr != a.m_ptr){ // this 原来的那个区域处理 if(--(*m_count) == 0){ // 这里不仅仅是检查，也会引用计数减1 delete m_ptr; delete m_count; m_ptr = nullptr; m_count = nullptr; } m_ptr = a.m_ptr; m_count = a.m_count; ++(*m_count); } return *this; } int use_count(){ return *m_count; } int * use_countPtr(){ return m_count; } T* get(){ return m_ptr; } private: T *m_ptr; int *m_count; }; shared_ptr会产生循环引用问题，如下代码\ntemplate\u0026lt;class T\u0026gt; class sharedPtr{ public: sharedPtr(T *a):m_ptr(a), m_count(new int(1)) { }; ~sharedPtr(){ if(--(*m_count) == 0){ delete m_ptr; delete m_count; m_ptr = nullptr; m_count = nullptr; } } T\u0026amp; operator *(){ return *m_ptr; } T* operator-\u0026gt;(){ return m_ptr; } // 拷贝构造 sharedPtr(const sharedPtr\u0026lt;T\u0026gt; \u0026amp;a):m_ptr(a.m_ptr),m_count(a.m_count) { ++(*m_count); } // 赋值函数 sharedPtr\u0026lt;T\u0026gt; \u0026amp; operator=(const sharedPtr\u0026lt;T\u0026gt; \u0026amp;a){ if(m_ptr != a.m_ptr){ // this 原来的那个区域处理 if(--(*m_count) == 0){ // 这里不仅仅是检查，也会引用计数减1 delete m_ptr; delete m_count; m_ptr = nullptr; m_count = nullptr; } m_ptr = a.m_ptr; m_count = a.m_count; ++(*m_count); } return *this; } int use_count(){ return *m_count; } int * use_countPtr(){ return m_count; } T* get(){ return m_ptr; } private: T *m_ptr; int *m_count; }; int main() { struct Node{ Node():pre(nullptr), next(nullptr) { } int data; sharedPtr\u0026lt;Node\u0026gt; pre; sharedPtr\u0026lt;Node\u0026gt; next; }; int *c1 = nullptr; int *c2 = nullptr; { // 这里一个花括号，限制了作用域 sharedPtr\u0026lt;Node\u0026gt; a(new Node); sharedPtr\u0026lt;Node\u0026gt; b(new Node); a-\u0026gt;next = b; b-\u0026gt;pre = a; // 把各自的m_count取出来 c1 = a.use_countPtr(); c2 = b.use_countPtr(); cout \u0026lt;\u0026lt; *c1 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; *c2 \u0026lt;\u0026lt;endl; } // 因为上边a 和 b在析构时，没有释放m_ptr和m_count，所以，下边两行可以访问，并且为1 cout \u0026lt;\u0026lt; *c1 \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; *c2 \u0026lt;\u0026lt;endl; return 0; } 对象a和b本身为sharedPtr类型，内部各包含一个Node*并且开辟了内存。为了方便后续描述，a中申请的这块内存称之为A_Node*，b中的这块内存称之为B_Node*。\na和b初始化时，内部的引用计数均为1，因为这个时候只有自己使用自己内部的这块内存空间。 当执行了\na-\u0026gt;next = b; b-\u0026gt;pre = a; 这两行代码以后，a和b内部的引用技术均为2。此时对于a来说，不仅仅自己使用A_Node*，同时b中的一个sharedPtr\u0026lt;Node\u0026gt;类型（与a同类型）的pre，也使用A_Node*，所以a中的引用计数为2，b中pre内部的引用计数也为2。\n对于b来说，同理，不仅仅自己使用B_Node*，同时a中的一个sharedPtr\u0026lt;Node\u0026gt;类型（与b同类型）的next，也使用B_Node*，所以b中的引用计数为2，a中next内部的引用计数也为2。\n重点来了，当程序执行到花括号外边的时候，a和b两个对象的生命周期到了，要执行各自的析构函数。但是！执行a的析构函数时，由于引用计数为2，减去1之后不为0，所以，不会释放a内部的m_ptr和m_count，只不过把m_count变为了1，由于引用计数机制的存在，此时b中的pre，这个智能指针内部的引用计数也会变为1。总结一下，就是a这个对象被析构了，但是 A_Node* 没释放。\n同理，执行b的析构函数时，由于引用计数为2，减去1之后不为0，所以，不会释放b内部的m_ptr和m_count，只不过把m_count变为了1，由于引用计数机制的存在，此时a中的next，这个智能指针内部的引用计数也会变为1。总结一下，就是b这个对象被析构了，但是 B_Node* 没释放。\n经过了a和b两个对象的析构函数，现在的情况是怎么样的？\nA_Node*中的next指向B_Node*。 B_Node*中的pre指向A_Node*。\n此时呢，形成了环。\n在没有人为干预的情况下，想释放A_Node*，就必须先释放 B_Node*。\n因为一旦B_Node*释放，会触发B_Node*内部pre指针的析构函数，因此这时pre内部的引用计数为1，减1之后变为0，所以，可以释放掉pre所指向的内存空间，也就是会释放掉A_Node*，然后接着会触发A_Node*内部next指针的析构函数，同理，next指针会把自己指向的B_Node*给释放掉，这样，A_Node*和B_Node*这两块被a和b遗留下来的内存空间就可以正常被释放。\n但是！！！问题来了，想释放B_Node*，就必须先释放 A_Node*。\n二者互相等待，都等待对方先释放，这个就是循环引用。\n解决办法 把Node中的两个shared_ptr换成weak_ptr即可，这样，a和b的引用计数均为1，可以正常是释放。\n5. weak_ptr 是对shared_ptr的修改，实现逻辑如下代码。 实现的原则是：允许一块内存由多个指针拥有，与shared_ptr不同的是，不使用引用计数。 存在的问题：适用性不如shared_ptr广，因为一个weak_ptr释放的时候，就会把自己指向的区域释放掉，可能会重复释放。\n// weak ptr ，与sharedPtr的不同在于，没有引用计数，总是，weakPtr，共享，但不计数，直接释放 template\u0026lt;class T\u0026gt; class weakPtr{ public: weakPtr(T *a):m_ptr(a){ } ~weakPtr(){ if(m_ptr) { delete m_ptr; m_ptr = nullptr; } } // 赋值 weakPtr\u0026lt;T\u0026gt; \u0026amp; operator= (const weakPtr\u0026lt;T\u0026gt; \u0026amp;a){ if(m_ptr) delete m_ptr; m_ptr = a.m_ptr; return *this; } weakPtr\u0026lt;T\u0026gt; \u0026amp; operator= (T *a){ m_ptr = a; return *this; } T\u0026amp; operator *(){ return *m_ptr; } T* operator-\u0026gt;(){ return m_ptr; } private: T *m_ptr; }; ","permalink":"https://Clay-Hex.github.io/posts/2021/07/cpp-smart-pointers/","summary":"1. 什么是智能指针 简而言之，为了更安全的使用指针。 实现方式简单来说，就是用一个模板类把一般的指针包装起来。用这个类来维护内部指针的释放操作。 std中有四种智能指针。 auto_ptr（已弃用） unique_ptr shared_ptr weak_ptr 2. auto_ptr 比较简单的智能指针，实现逻辑如下代码。 实现的原则是：内存空间只能由一个指针所拥有。","title":"C++学习记录(11) 智能指针"},{"content":"0. 为什么要内存对齐？ 经过内存对齐之后，一个最最主要的原因是可以使得CPU的内存访问速度大大提升。 内存空间按照byte划分，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。\n用空间换时间！\nCPU在读内存的时候是n个为一组的方式去读。 假设此时4个字节为一组去读。\n内存对齐之后的内存空间如下图：\n这样的话，只需要读内存2次。\n先从第一组读，然后扣除0位置，a就读取结束了。 读b的时候，先读第一组，扣除1，2，3。然后读第二组，扣除4，拼起来组成变量b。\n这样的话。一共读了3次。\n1. 内存对齐的原则? #pragma pack(N); // N 字节对齐； 默认为4(32位), 8(64位) 数据成员对齐规则： * 第一个成员offset = 0; * 后面每个成员的起始位置为：min( N, 自身长度) 的 倍数\n如果成员中有结构体，那么该结构体的起始位置为，min( N, 结构体内部所有成员最大长度) 的倍数\n结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍\n注意，N必须为1,2,4,8\u0026hellip;这种才生效，否则的话，都是按默认的字节数进行对齐。\n","permalink":"https://Clay-Hex.github.io/posts/2021/06/cpp-memory-alignment/","summary":"0. 为什么要内存对齐？ 经过内存对齐之后，一个最最主要的原因是可以使得CPU的内存访问速度大大提升。 内存空间按照byte划分，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列","title":"C++学习记录(10) 内存对齐"},{"content":"转自：https://www.cnblogs.com/stemon/p/4406824.html\n前几天女票问了我一个阿里的面试题，是有关C++语言的const常量的，其实她一提出来我就知道考察的点了：肯定是const常量的内存不是分配在read-only的存储区的，const常量的内存分配区是很普通的栈或者全局区域。也就是说const常量只是编译器在编译的时候做检查，根本不存在什么read-only的区域。\n所以说C++的const常量和常量字符串是不同的，常量字符串是存储在read-only的区域的，他们的具体的存储区域是不同的。\n就好像杨立翔老师在上课举得那个例子（讲的东西忘得差不多了，但是例子都记得，什么撕户口本，月饼模子之类的）：\n场景：老式的电影放映机，门口的检票员，最后排那个座位上的放映师傅，好多的观众席。\n你的电影票上有你的名字，检票员的手里有个名字和座位号的对应表，检票员不允许观众乱坐位置。\n所以游戏就这样开始了，电影院的每一个观众席都是const常量类型的，检票员就是编译器，在观众进门的时候，每个人都必须坐自己票上的位子，也就是说观众必须拿着自己的票进门。你拿着别人的票就不让你进去，所以就不能更换座位。\n类比到C++语言上，场景应该是这样的：对于哪些const常量，在编译的时候就已经决定了，他们在内存的存储位置，你如果直接改这个常量的值是不合法的。就好像你不能拿着一张别人的电影票进电影院，因为检票员手里有一张座位号到姓名的映射表，他知道哪个座位该坐谁，并且不让观众随意调换（这个例子尼玛真的好形象啊，杨老师说的没有这么好，我后期根据自己的理解稍微添油加醋）。其实检票员手里的那张映射表就是编译器的符号表，是不是真的很形象，关于这个符号表后面说。\n那么新的问题来了，观众进到电影院以后，我跟旁边的哥们说一声，我给你100块，你给我换一下位置吧，如果他同意了，我们就能换。检票员管不着，进都进来了，还能怎样。所以两个人就调换了位子。\nC++的const常量一样是这个样子，编译器在编译的时候要查看它手里的符号表，如果你拿的是一个const常量，并且你要修改这个常量的值，他就拒绝。但是这种检查值会发生在编译器，如果我能绕过编译器，在运行的时候修改这个const的值，将会是很easy的一件事，就像前面说的，我给那哥们100块就搞定了。所以说const常量的存储空间同其他的变量的存储空间没有任何的区别，它的这种常量不允许就该的检查只发生在编译器的编译阶段。\n但是常量字符串的存储位置就不同了，它的存储位置是read-only的区域，就像电影院最后的那个放映师的位置，那里是一个特殊的位置，是真的不允许随便的调换，你给他1000也不给你换，因为师傅要在那个位置放映，不然没法看电影。当然了，实现这种read-only的存储区域也很简单，把那个内存的页（page）的属性标记为只读的就好了。\n对了，当时我还想起了这个：\nconst int *p1; /* p1所指向的int变量值不可改变，为常量，但可以改变p1指针的值 */ int * const p2; /* p2指针为常量，即p2的值不可改变，但可以改变p2指向对象的值 */ const int * const p3; /* p3指针是常量，同时p3所指向int对象的值也是常量 */ 啰啰嗦嗦说这么长一个例子，其实很简单的道理，就是为了好玩，好记。先宏观的说一下const常量的实现机制，下面说一些具体的实现。\n其实女票提出的问题不算难，是C++语言的一个知识点，总而言之就是一个常量折叠。\n先说一个错误的理解（为什么要说一个错误的理解，因为它有助于正确的理解，哈哈）：可折叠的常量就像宏一样，在预编译阶段对const常量的引用一律被替换为常量所对应的值。就和普通的宏替换没有什么区别，并且编译器不会为该常量分配存储空间。\n看清楚了，上面说的是一个错误的理解，常量折叠确实会像宏替换一样把对常量的引用替换为常量对应的值，但是该常量是分配空间的，并且靠编译器来检查常量属性。\n#define PI 3.14 int main() { const int r = 10; int p = PI;//这里在预编译阶段产生宏替换，PI直接替换为3.14，其实就是int p = 3.14 int len = 2 * r;//这里会发生常量折叠，也就是说常量r的引用会替换成它对应的值，相当于int len = 2 * 10; return 0; } 如上述代码中所述，常量折叠表面上的效果和宏替换是一样的，只是，“效果上是一样的”，而两者真正的区别在于，宏是字符常量，在预编译阶段的宏替换完成后，该宏名字会消失，所有对宏如PI的引用已经全部被替换为它所对应的值，编译器当然没有必要再维护这个符号。而常量折叠发生的情况是，对常量的引用全部替换为该常量如r的值，但是，常量名r并不会消失，编译器会把他放入到符号表中，同时，会为该变量分配空间，栈空间或者全局空间。既然放到了符号表中，就意味着可以找到这个变量的地址（埋一个伏笔先）。\n符号表不是一张表，是一系列表的统称，这里的const常量，会把这个常量的名字、类型、内存地址、值都放到常量表中。符号表还有一个变量表，这个表放变量的名字、类型、内存地址，但是没有放变量的值。\n为了更能体现出常量折叠，看下面的对比实验：\nint main() { int i0 = 11; const int i = 0; //定义常量i int *j = (int *) \u0026amp;i; //看到这里能对i进行取值，判断i必然后自己的内存空间 *j = 1; //对j指向的内存进行修改 printf(\u0026#34;0x%p\\n0x%p\\n%d\\n%d\\n\u0026#34;,\u0026amp;i,j,i,*j); //观看实验效果 const int ck = 9; //这个对照实验是为了观察，对常量ck的引用时，会产生的效果 int ik = ck; int i1 = 5; //这个对照实验是为了区别，对常量和变量的引用有什么区别 int i2 = i1; return 0; } 下面看一下不同编译器的输出结果 vc6.0：\nvs2010：\ng++的输出结果：\n注意：对于Linux的GUN中的gcc是用来编译.c文件的C语言编译器，g++是用来编译.cpp的C++语言编译器。\n我们这里讲的是C++的商量折叠，所以源文件要是.cpp的才可以。（C语言的const常量最后再说）\n上面的程序的运行结果至少说明两点：\n（1）i和j地址相同，指向同一块空间，i虽然是可折叠常量，但是，i确实有自己的空间\n（2）i和j指向同一块内存，但是*j = 1对内存进行修改后，按道理来说，*j==1,i也应该等于1，而实验结果确实i实实在在的等于0。 这是为什么呢，就是本文所说的内容，i是可折叠常量，在编译阶段对i的引用已经别替换为i的值了，同时不同于宏替换的是，这个i还被存到了常量表中。 也就是说：\nprintf(\u0026#34;0x%p\\n0x%p\\n%d\\n%d\\n\u0026#34;,\u0026amp;i,j,i,*j); 中的i在预处理阶段已经被替换，其实已经被改为：\nprintf(\u0026#34;0x%p\\n0x%p\\n%d\\n%d\\n\u0026#34;,\u0026amp;i,j,0,*j); 同时在常量表中也有i这个变量，不然的话对i取地址是不合法的，这是和宏替换的不同点，宏替换是不会把宏名称放到常量表中的，预编译完就用不到了。\n为了更加直观，下面直接上这个程序的反编译的汇编语言：\n（1）方法：打个断点调试-\u0026gt;窗口反汇编（还有好多功能，比如内存多线程等）\n（2）反汇编代码：\n--- d:\\cv_projects\\commontest\\commontest\\commontest.cpp ------------------------ #include \u0026lt;stdio.h\u0026gt; int main() { 01311380 push ebp 01311381 mov ebp,esp 01311383 sub esp,114h 01311389 push ebx 0131138A push esi 0131138B push edi 0131138C lea edi,[ebp-114h] 01311392 mov ecx,45h 01311397 mov eax,0CCCCCCCCh 0131139C rep stos dword ptr es:[edi] int i0 = 11; 0131139E mov dword ptr [i0],0Bh const int i = 0; //定义常量i 013113A5 mov dword ptr [i],0 //编译器确实为常量i分配了栈空间，并赋值为0 int *j = (int *) \u0026amp;i; //看到这里能对i进行取值，判断i必然后自己的内存空间 013113AC lea eax,[i] 013113AF mov dword ptr [j],eax *j = 1; //对j指向的内存进行修改 013113B2 mov eax,dword ptr [j] 013113B5 mov dword ptr [eax],1 printf(\u0026#34;0x%p\\n0x%p\\n%d\\n%d\\n\u0026#34;,\u0026amp;i,j,i,*j); //观看实验效果 013113BB mov esi,esp 013113BD mov eax,dword ptr [j] 013113C0 mov ecx,dword ptr [eax] 013113C2 push ecx 013113C3 push 0 013113C5 mov edx,dword ptr [j] 013113C8 push edx 013113C9 lea eax,[i] 013113CC push eax 013113CD push offset string \u0026#34;0x%p\\n0x%p\\n%d\\n%d\\n\u0026#34; (131573Ch) 013113D2 call dword ptr [__imp__printf (13182B0h)] 013113D8 add esp,14h 013113DB cmp esi,esp 013113DD call @ILT+295(__RTC_CheckEsp) (131112Ch) const int ck = 9; //这个对照实验是为了观察，对常量ck的引用时，会产生的效果 013113E2 mov dword ptr [ck],9 //为常量分配栈空间，这是符号表中已经有了这个变量 int ik = ck; 013113E9 mov dword ptr [ik],9 //看到否，对常量ck的引用，会直接替换为常量的值9，这种替换很类似于宏替换，再看下面的实验 int i1 = 5; //这个对照实验是为了区别，对常量和变量的引用有什么区别 013113F0 mov dword ptr [i1],5 int i2 = i1; //这里引用变量i1，对i2进行赋值，然后看到否，对常量i1引用没有替换成i1的值，而是去栈中先取出i1的值，到edx寄存器中，然后再把值mov到i2所在的内存中 013113F7 mov eax,dword ptr [i1] 013113FA mov dword ptr [i2],eax return 0; 013113FD xor eax,eax } 通过上述实验的分析可以容易看出，对可折叠的常量的引用会被替换为该常量的值，而对变量的引用就需要访问变量的内存。\n总结：常量折叠说的是，在编译阶段，对该变量进行值替换，同时，该常量拥有自己的内存空间，并非像宏定义一样不分配空间，需澄清这点\n前面说了个不许用gcc编译.c的C语言的程序，不然就没有了常量折叠的问题，先看一下执行的结果：\n最后说一下gcc编译的C语言的const常量，这里并没有做常量折叠的这种优化，类似于const常量前面加上volatile这个关键字。具体是怎么回事？下一篇博客再说。\n","permalink":"https://Clay-Hex.github.io/posts/2021/06/cpp-constant-folding/","summary":"转自：https://www.cnblogs.com/stemon/p/4406824.html 前几天女票问了我一个阿里的面试题，是有关C++语言的const常量的，其实她一提出来我就知道考察的点了：肯定是const常量的内存不是分配在read-only的存储区的，const常量","title":"C++学习记录(9) 常量折叠"},{"content":"0. 模板 C++中除了有面向对象的思想，还有泛型编程的思想，泛型编程利用的主要技术就是模板。 C++中两种模板：函数模板、类模板\n语法：\ntemplate\u0026lt;typename T\u0026gt; 函数声明或定义 含义：\ntemplate 固定的，声明创建模板 typename 表明后边的T是一种数据类型，也可以用class代替 T 类似形参，任意的合法字符都可以，习惯上用 T 模板有两种类型推导的方式，一种是编译器自动推导，另外一种是程序猿手动指定：\n#include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; void func(T \u0026amp;a, T \u0026amp;b){\tT s = a; a = b; b = s; } int main(){ int a = 10, s = 9; // func(a, s); // 自动类型推导 // func\u0026lt;int\u0026gt;(a, s); // 指定类型推导 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 1. 函数模板注意事项 自动类型推导，必须推导出一致的数据类型才可以使用。 模板必须要确定 T 的数据类型，才可以使用。 eg:二分排序的模板实现\ntemplate\u0026lt;typename T\u0026gt; void mySort(T a[], int len, int l, int r){\t// quickSort if(l \u0026gt;= r) return ; int x = a[(l + r) / 2]; int i = l - 1, j = r + 1; while(i \u0026lt; j){ while(a[++i] \u0026lt; x); while(a[--j] \u0026gt; x); if(i \u0026lt; j) swap(a[i], a[j]); } mySort(a, len, l, j); mySort(a, len, j + 1, r);\t} 2. 普通函数与函数模板对比 2.1 区别 普通函数调用时，参数可以发生自动类型转换（隐式转换） 函数模板，在自动类型推导形式下，不会自动类型转换。 函数模板，在指定类型形式下，会发生自动类型转换。 2.2 调用规则 如果普通函数和函数模板同时存在，则会调用普通函数，如果普通函数只有声明，没有实现，那也不会去调用函数模板，会直接报错 可以用过空模板参数列表，强制调用函数模板 函数模板也可以重载 如果函数模板可以更好的匹配调用，会优先调用函数模板 #include \u0026lt;iostream\u0026gt; using namespace std; void fuc(int a, int b){ cout \u0026lt;\u0026lt; \u0026#34;普通\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; void fuc(T a, T b){ cout \u0026lt;\u0026lt; \u0026#34;模板\u0026#34; \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; // 重载函数模板 void fuc(T a, T b, T c){ cout \u0026lt;\u0026lt; \u0026#34;模板 重载\u0026#34; \u0026lt;\u0026lt; endl; } void test(){ int a = 1; int b = 2; fuc(a, b); // 调用普通函数 fuc\u0026lt;\u0026gt;(a, b); // 空模板参数列表，调用函数模板 fuc\u0026lt;\u0026gt;(a, b, 1); // 模板 重载 char c1 = \u0026#39;a\u0026#39;; char c2 = \u0026#39;s\u0026#39;; fuc(c1, c2); // 传入char型，普通函数需要做自动类型转换，而函数模板不需要转换，所以优先调用函数模板。 } int main(){ test(); return 0; } 3. 模板的局限性 比如模板是一个赋值操作，那么传入的是数组的话，就不正确了。 再比如，比较两个对象的大小关系，类型不确定，比较方式也不确定。\n为了解决上边问题，C++提供了模板的重载，可以为特定的类型提供具体化的模板（当然，也可以在重载特定类型的运算符）\n语法：\ntemplate\u0026lt;class T\u0026gt; void fuc(T a, T b){ cout \u0026lt;\u0026lt; \u0026#34;原模板\u0026#34; \u0026lt;\u0026lt; endl; } // test是自定义的数据类型 // 这里将函数模板为test数据类型具体化，如果传入是test类型的话，优先调用具体化的模板 template\u0026lt;\u0026gt; void fuc(test a, test b){ // ... code } 4. 类模板 作用：建立一个通用类，类的成员的数据类型可以不指定，用一个虚拟的类型来代表。 语法：和函数模板一样\ntemplate\u0026lt;typename T\u0026gt; 类 例程：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class nameType, class ageType\u0026gt; class Person{ public: Person(nameType name, ageType age) : m_name(name), m_age(age){ }; void print(){ cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; endl; } string m_name; int m_age; }; int main(){ Person\u0026lt;string, int\u0026gt; a(\u0026#34;张三\u0026#34;, 18); a.print(); return 0; } 5. 类模板与函数模板区别 类模板没有自动类型推导，必须指定类型。 类模板在参数列表中，可以有默认参数，在C++11标准以后，函数模板也可以有默认参数了。 上边的代码可以改成这：\ntemplate\u0026lt;class nameType = string, class ageType = int\u0026gt; 6. 类模板中成员函数创建的时机 类模板中的成员函数与普通类的成员函数创建时机有所区别：\n普通类的成员函数一开始就可以创建。 类模板的成员函数在调用时才创建。 类模板的成员函数在调用时才创建的原因如下：\n因为类中的某些类型并不确定，传入的类型到底能不能执行成员函数中的动作也不知道，所以不能提前创建。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Person1{ public: void f1(){ cout \u0026lt;\u0026lt; \u0026#34;f1\u0026#34; \u0026lt;\u0026lt; endl; } }; class Person2{ public: void f2(){ cout \u0026lt;\u0026lt; \u0026#34;f2\u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;class T\u0026gt; class tt{ public: T obj; void f1(){ obj.f1(); } void f2(){ obj.f2(); } }; int main(){ tt\u0026lt;Person1\u0026gt; s; s.f1(); // 合法 s.f2();\t// 不合法 因为类模板指定的类型是Person1，而该类型没有f2的方法。 return 0; } 7. 类模板实例化的对象 做 函数参数 函数参数有三种类型进行接收：\n指定类型 ： 对象是什么类型，直接将该类型作为函数参数 把类模板的参数 模板化： 将对象中的参数变为模板 把 类模板整体 模板化 第一种在实际开发中最常用，因为后两种需要函数模板配合类模板，麻烦。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class T1, class T2\u0026gt; class Person{ public: T1 m_name; T2 m_age; Person(T1 name, T2 age){ m_name = name; m_age = age; } void print(){ cout \u0026lt;\u0026lt; \u0026#34;name : \u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; age : \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; endl; } }; //1. 指定类型 void printP1(Person\u0026lt;string, int\u0026gt; \u0026amp;a){ a.print();\t} // 2. 参数模板化 template\u0026lt;class T1, class T2\u0026gt; void printP2(Person\u0026lt;T1, T2\u0026gt; \u0026amp;a){ a.print(); } // 3. 类模板 模板化 template\u0026lt;class T\u0026gt; void printP3( T \u0026amp;a){ a.print(); } int main(){ Person\u0026lt;string, int\u0026gt; a(\u0026#34;张三\u0026#34;, 33); printP1(a); printP2(a); printP3(a); return 0; } 8. 类模板遇到继承 在继承时，如果父类是一个类模板，那么必须指定父类模板的数据类型。 如果想灵活继承父类模板，那么子类也需要做成类模板。 9. 类模板成员函数类外实现 template\u0026lt;class T1, class T2\u0026gt; class Person{ public: T1 m_name; T2 m_age; Person(T1 name, T2 age); void print(); }; template\u0026lt;class T1, class T2\u0026gt; Person\u0026lt;T1, T2\u0026gt;::Person(T1 name, T2 age){ m_name = name; m_age = age; } template\u0026lt;class T1, class T2\u0026gt; void Person\u0026lt;T1, T2\u0026gt;::print(){ cout \u0026lt;\u0026lt; \u0026#34;name : \u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34; age : \u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; endl; } 10. 类模板分文件编写 类模板的声明在.h文件中，类模板的成员函数在相关联的.cpp文件中实现。 这种情况下，如果在别的文件中（比如main.cpp）引入该 .h文件，使用该类，会无法编译（无法解析外部符号），为什么？\n原因是，类模板的成员函数在调用时才会创建。main.cpp引入了.h文件，该文件中只有类模板的声明，没有具体实现。\n为了解决这个问题，有两种解决方法：\n法1：不include类的.h文件，而是include类的.cpp文件。 法2：可以将类模板的声明和实现写在同一个文件中，并且习惯上把该文件的后缀名写成 .hpp。 实际中，第二种方法更加普遍。\n11. 类模板的友元 类内定义：与普通类定义友元一样。 类内声明，类外定义：类外定义的话，肯定要声明称模板，而类内的声明语句，会认为是一个普通的函数，所以，类内的声明要加上空参数列表friend test\u0026lt;\u0026gt;(test\u0026lt;T1, T2\u0026gt;);说明这是一个模板，并不是一个普通的函数。 例程：\n#include \u0026lt;iostream\u0026gt; using namespace std; // 声明有Person类 要不然test2找不到Person类 template\u0026lt;class T\u0026gt; class Person; // 声明test2是个模板函数，要不然下边的Person类中找不到test2这个模板函数 template\u0026lt;class T\u0026gt; void test2(Person\u0026lt;T\u0026gt; a){ cout \u0026lt;\u0026lt; a.a \u0026lt;\u0026lt; endl; } template\u0026lt;class T\u0026gt; class Person{ // 1. 类内实现友元 friend void test1(){ // 友元函数声明 + 定义，如果不加friend的话，相当于一个普通的成员 cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; endl; } // 2. 类外实现友元 这里声明要加空参数列表 说明需要的是一个模板函数 friend void test2\u0026lt;\u0026gt;(Person\u0026lt;T\u0026gt;); public: Person(T age){ a = age; } T a; }; // test1函数的声明 供main调用。 void test1(); int main(){ Person\u0026lt;int\u0026gt; a(10); test2(a); return 0; } ","permalink":"https://Clay-Hex.github.io/posts/2021/02/cpp-template/","summary":"0. 模板 C++中除了有面向对象的思想，还有泛型编程的思想，泛型编程利用的主要技术就是模板。 C++中两种模板：函数模板、类模板 语法： template\u0026lt;typename T\u0026gt; 函数声明或定义 含义： template 固定的，声明创建模板 typename 表明后边的T是一种数据类型，也可以用class代替 T 类似形参，任意的合法字符都可以，习惯上用 T 模板有两种","title":"C++学习记录(8) 模板"},{"content":"0. 基本语法 多态是面向对象的三大特性之一。\n多态：多态即调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。\n多态分为两类\n静态多态：函数重载 和 运算符重载 属于静态多态，是对函数名的复用。 动态多态：派生类和虚函数实现运行时多态。 静态多态的函数地址早绑定， 编译阶段确定函数地址。 动态多态的函数地址晚绑定， 运行阶段确定函数地址。 引入虚函数，就是为了通过函数重写实现多态的效果。\n动态多态需要满足的条件：\n出现在继承当中 子类重写父类的虚函数，注意，必须是虚函数，重写非虚函数的话实质是函数覆盖了。 动态多态的使用条件：\n父类的指针或者引用，指向了子类对象。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; class base{ public: virtual void speak(){ cout \u0026lt;\u0026lt; \u0026#34;base在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; class son : public base { public: void speak(){ // 重写了父类的虚函数 实现了多态 cout \u0026lt;\u0026lt; \u0026#34;son在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; // C++中 有自动的父子类 类型转换 void speak(base \u0026amp;person){ // 使用引用触发多态 person.speak(); } int main(){ base b; son s; speak(s); return 0; } 1. 多态的原理 类中定义了虚函数的话，实例化一个对象 a 以后，就会在 a 中产生一个虚函数指针vfptr，指向虚函数表（vftable）。\n简而言之，子类在虚函数表中替换了重写函数的那条记录。\n2. 纯虚函数和抽象类 纯虚函数语法：virtual 返回值类型 函数名 （参数列表） = 0，无需大括号。\n当类中有了一旦有了纯虚函数，这个类就成为了抽象类 抽象类特点：\n抽象类无法实例化对象，但可以指向子类对象。 子类必须重写抽象类中的纯虚函数，否则也属于抽象类，就无法实例化对象。 class base{ public: virtual void speak() = 0; // 纯虚函数 int a; }; class son : public base { public: void speak(){ // 重写了父类的虚函数 实现了多态 cout \u0026lt;\u0026lt; \u0026#34;son在说话\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ base *b = new son; // 父类指针指向了子类 这就实现了多态 son ss; // 子类直接实例化出一个对象 return 0; } 3. 虚析构和纯虚析构 作用：\n解决通过父类指针无法释放子类对象的问题。 如果子类中没有堆区数据，可以不写虚析构或纯虚析构 拥有纯虚析构也属于抽象类，无法直接实例化对象。 问题：多态使用时（父类指针或引用指向了子类），如果子类中有属性开辟到了堆区，那么父类指针在释放时无法调用子类的析构代码。\n解决办法：将父类中的析构函数改为虚的或者纯虚的。\n测试代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; class base{ public: virtual void f() = 0; // 纯虚函数 base(){ cout \u0026lt;\u0026lt; \u0026#34;base 构造函数\u0026#34; \u0026lt;\u0026lt; endl; } ~base(){ cout \u0026lt;\u0026lt; \u0026#34;base析构\u0026#34; \u0026lt;\u0026lt; endl; } }; class son : public base { public: void f(){ cout \u0026lt;\u0026lt; \u0026#34;void f fuction in son\u0026#34; \u0026lt;\u0026lt; endl; } son(){ cout \u0026lt;\u0026lt; \u0026#34;son构造函数\u0026#34; \u0026lt;\u0026lt; endl; } ~son(){ cout \u0026lt;\u0026lt; \u0026#34;son析构\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(){ base *b = new son; delete b; return 0; } 输出:\nbase构造 son构造 base析构 在base析构前边，没有son析构，如果子类中在堆区开了空间，那就会造成内存泄漏。\n此时，如果把base类中的析构函数加上virtual修饰，变成一个虚函数，那么在释放父类指针的时候，就会触发子类的析构函数了，把子类释放掉。\n一个纯虚的析构函数，除了有声明，还必须要有具体实现，类内声明，类外定义 ","permalink":"https://Clay-Hex.github.io/posts/2021/02/cpp-polymorphic/","summary":"0. 基本语法 多态是面向对象的三大特性之一。 多态：多态即调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 多态分为两类 静态多态：函数重载 和 运算符重载 属于静态多态，是对函数名的复用。 动态多态：派生类和虚函数实现运行时多态。 静态多态的函数地址早绑定， 编译阶段确定函数地址。 动态多","title":"C++学习记录(7) 多态"},{"content":"0. 基本语法 继承是面向对象的三大特性之一。\nclass 子类 ： 继承方式 父类\n从父类继承来的表现其共性，而新增的成员表现其个性。\n1. 继承方式 三种继承方式\npublic protected private 父类中的private成员，无论哪种方式都不能访问。 2. 继承中的对象模型 问题：从父类继承来的成员，哪些属于子类对象中？\n输出子类的sizeof可以看出，父类中的所有非静态成员都会被子类继承下去，无论哪种继承方式。\n3. 父类和子类的构造和析构顺序 构造：先base后son 析构：恰恰相反，先son后base\n4. 同名成员的处理 要访问子类成员：直接访问 要访问父类成员：加上作用域 son.base::a 父子类出现重名成员函数时，子类会屏蔽掉父类中所有的同名函数（如果父类中有重载，也全都屏蔽掉），如果想访问，就需要加上父类作用域。因为这是在重写父类中的非虚函数，该函数是在编译阶段完成地址绑定的。如果非要重写非虚函数，在设计上是矛盾的，父类把该函数设计成非虚函数的本意就是不希望子类去更改该函数。 5. 多继承 C++允许一个类继承多个类 语法：class 子类 ： 继承方式 父类1， 继承方式 父类2。。。 多继承可能会引发父类中有同名成员出现，需要加作用域区分。 C++实际开发中不建议使用多继承。\n6. 菱形（钻石）继承 b类和c类继承于a类，d类又同时继承于b类和c类，就叫做菱形继承。\n会出现的问题：\n两个父类会有相同的数据，需要加以作用域进行区分。 菱形继承会导致数据有两份（来自b和来自c的都有一份），导致资源浪费。此时使用虚基类可以解决。 vbptr虚基类指针会指向vbtable虚基类表。\n虚继承可能实际中不太会用到，因为多继承都很少用到，大概率是在面试中出现，知道底层实现的原理即可。\n","permalink":"https://Clay-Hex.github.io/posts/2021/02/cpp-inheritance/","summary":"0. 基本语法 继承是面向对象的三大特性之一。 class 子类 ： 继承方式 父类 从父类继承来的表现其共性，而新增的成员表现其个性。 1. 继承方式 三种继承方式 public protected private 父类中的private成员，无论哪种方式都不能访问。 2. 继承中的对象模型 问题：从父类继承来的成员，哪些属于子类对象中？ 输出子类的sizeof可以","title":"C++学习记录(6) 继承"},{"content":"0. 类的4个默认函数 4个函数：构造函数、析构函数、拷贝构造函数、赋值号重载函数。 在定义类时，如果没有自定义这些函数，编译器会提供默认的函数，在默认的函数中，构造函数、析构函数默认空实现，拷贝构造函数、赋值号重载函数默认是浅拷贝。\n拷贝构造函数作用：\n参数是一个同类型的对象，直接拷贝这个参数的所有属性，注意，这个拷贝默认是浅拷贝，需要深拷贝的话需要重载拷贝构造函数。 【注】\n如果在实例化一个对象的时候，后边加了一个空括号，编译器会认为这是一个函数声明而不是实例化，所以，如果一个类的构造函数没有参数的时候，实例化时不用附加空括号. Person a(); // 这样会认为是一个函数声明 Person a; // 应该这样 不要用拷贝构造函数去初始化一个匿名对象，否则从编译器会认为这是重定义。\n可以像这样给构造函数传参Person aaa = 10; 隐式转换法。\n如果没有自定义构造函数的话，C++会自动分配空的构造函数和 只会浅拷贝的拷贝构造函数\n1. 类的访问说明符（访问权限） public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问； protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问； private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象访问。 三者都允许友元访问。 protected和public的区别就在于类的类外可不可以调用。 protected和private的区别就在于子类是否可以访问，private权限给的最小，子类都不可以访问。 总结：按照类的对象是否可以访问，可以将后两个分成一类，按照子类是否可以访问，可以将前两个分成一类。\n2. 友元 对于不完全开放的protected和private中的成员，类 可以为友元函数（类）提供单独的访问权限。\n全局函数可以做友元 类可以做友元 类的成员函数可以做友元 友元函数的声明必须在类内，最好是在类的开始位置。但是友元函数的定义或者说实现即可在在类内，也可以在类外。\n友元的声明仅仅指定了访问权限，而非通常意义上的函数声明，如果我们希望类的用户可以调用某个友元函数，那么我们就必须在友元声明之外，再专门对该函数进行一次声明（提供给用户）。\n为了方便，通常把友元的声明与类本身放置在同一个头文件中（类的外部单独对该函数声明，以备外部调用方便）。\n类内进行友元函数定义，相当于定义了一个全局函数。 参考代码：\n#include \u0026lt;iostream\u0026gt; using namespace std; class Person{ friend void test(){ // 友元函数声明 + 定义，如果不加friend的话，相当于一个普通的成员 cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; endl; } public: int a; }; // test函数的定义在Person类的内部，现在想使用它，必须单独进行声明，告诉编译器，我已经定义了test函数，直接调用没问题。 void test(); int main(){ test(); return 0; } 3. 内联函数 一般来说，内联机制用于优化规模较小、流程简单、频繁调用的函数。 在编译时，直接把内联函数替换到调用它的地方，这样就省去了运行时调用函数的开销。\n类内定义的成员函数默认都是inline的。 类外定义的成员函数默认都不是inline的，想使用的话，可以加上inline说明。同时，需要把类的定义和该类外定义的成员函数 放在同一个文件中，否则编译时找不到内联函数。 4. 深拷贝与浅拷贝 如果没有自定义构造函数的话，C++会自动分配空的构造函数和 只会浅拷贝的拷贝构造函数\n在执行拷贝构造函数的时候，如果第一个对象 a1 在堆上开了一个指针 p 指向的地址是0x0011，a2使用a1进行初始化（使用拷贝构造函数复制a1的值）。所有属性完全复制，所以a2中的p所指的地址也是0x0011，并没有重新开辟一个堆的空间。所以如果a1先被释放了的话，a2再使用这个指针进行操作，就会产生异常了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class TEST{ public: TEST(int a){ age = new int(a); } ~TEST(){ if(age != nullptr){ delete age; age = nullptr; } } int *age = nullptr; }; int main(){ TEST a1(10); TEST a2(a1); cout \u0026lt;\u0026lt; *a1.age \u0026lt;\u0026lt; endl; //a1.~TEST(); cout \u0026lt;\u0026lt; *a2.age \u0026lt;\u0026lt; endl; return 0; } 编译器默认给的拷贝构造函数就是只会浅拷贝，想实现深拷贝，需要自己动手。\n5. 类a作为类b的成员 先构造成员类 a， 再构造 b。 先析构b，再析构成员类a，也就是说析构的顺序与构造的顺序相反。\n6. 静态成员 静态成员：用static修饰的成员变量或函数，也是可以设置public、private等访问权限的。 特点：类内声明，类外初始化。 静态成员变量：\n所有实例化后的对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化int test::age = 10; 静态成员函数：\n所有实例化后的对象共享一个函数 静态成员函数只能访问静态成员变量（因为静态成员函数只有一份，这个类可能实例化出来好多对象，如果调用的不是静态成员变量（每个对象都会拷贝出来一个），它根本不知道去访问哪一个对象的变量）。 静态的成员（包括变量和函数）都可以不实例化对象直接进行访问和调用\n#include \u0026lt;iostream\u0026gt; using namespace std; class test{ public: // 这里如果是private，那么外部就不可以访问了，只能在类中操作 static int a; }; int test::a = 10; int main(){ test a; cout \u0026lt;\u0026lt; test::a \u0026lt;\u0026lt; endl; // private修饰下不允许访问 cout \u0026lt;\u0026lt; a.a \u0026lt;\u0026lt; endl; // private修饰下不允许访问 return 0; } 7. 对象模型和this指针 类中的变量和函数是分开存储的，类通过一些办法将他们组织到一起，构成了一个类。\n变量、函数、静态变量、静态函数四者中，只有变量是属于类的对象上的，其他三个都不属于类的对象上。 原因： 每一个非静态成员函数其实只有一份。各个实例化了的对象调用自己的这个成员函数时，this指针指向该对象，该成员函数通过 this 指针区分是哪个对象调用了它。可以使用 *this返回对象自己。\n#include \u0026lt;iostream\u0026gt; using namespace std; class test{ public: test(int a){ age = a; } test \u0026amp;add( int a){ // 注意这里 返回是引用 否则返回的就是原始对象本身了 就是原始对象的一个拷贝，就不能满足链式编程的思想 age += a; return *this; } int age; }; int main(){ test a(10); // 这也是链式编程的思想 a.add(3).add(3); cout \u0026lt;\u0026lt; a.age \u0026lt;\u0026lt; endl; // 输出16 return 0; } 一个空的指针也是可以访问类内函数的，但是要注意，此时类内的this指针也是null，所以，如果用空指针调用类内函数，并且类内函数访问了成员变量（完整形式是 this -\u0026gt; 成员变量），就相当于对null进行访问，程序就会出错。 8. const修饰成员函数 常函数：\n是用const修饰的成员函数 常函数不可修改成员属性（除了mutable的属性） 常对象：\n使用const修饰一个实例化的对象，即为常对象 常对象只能调用常函数 为什么const修饰过的函数（常函数）不能修改成员属性？\n修改成员属性实际上是this下的属性，this指针实际上是指针常量(* const )，一旦实例化了一个对象，this指针就指向了它，且不能再更改了。 在成员函数参数列表后边加上const进行修饰，相当于说：在本函数中，this指向的空间也是const的了，也不允许通过this进行修改了。 #include \u0026lt;iostream\u0026gt; using namespace std; class test{ public: // this 指针相当于指针常量 test * const this // 函数后加了一个const 修饰的其实是this所指的空间 即 const test * const this // 即加了const，在本函数内 this所指的空间 不允许通过this进行改变了 void fuc1() const { this -\u0026gt; a = 10; // 编译器报错 } int a; }; int main(){ test p; p.fuc1(); return 0; } 为什么常对象只允许调用常函数？\n可以这样理解：常对象本身的意思就是只读，如果调用了一个非常函数，万一这个函数对自己的属性进行了修改怎么办？所以，直接在根本上拒绝这样危险的操作，直接限定常对象只允许调用常函数，因为常函数肯定修改不了自己的属性。 9. 重载运算符 9.1 基本运算符重载 以加法为例，就相当于自己在类里边写了一个做加法的函数，但是函数名统一成operator +了，可以通过这个函数名像普通成员函数那样调用a.operator+( b )，但是，也可以简写为 a + b。\n运算符重载，也可以发生函数重载，比如加法运算，可以是两个类做相加，也可以是一个类和一个整数相加。 9.2 左移运算符重载 作用：输出自定义的数据类型eg: cout \u0026lt;\u0026lt; class\n如果在类内定义左移重载运算符的话类本身就默认作为左操作数了，那么cout就只能在右边，比如class \u0026lt;\u0026lt; cout，可见这是不符合预期的，所以左移运算符的重载，一般不写在类中，都写成全局函数的形式。 为了满足链式编程，返回值也要是输出流的引用。 inline ostream \u0026amp;operator\u0026lt;\u0026lt; (ostream \u0026amp;out, test \u0026amp;s){ out \u0026lt;\u0026lt; s.a; return out; } 此时，重载运算符的函数是定义在全局函数中的，是如法访问类中的private成员的，还需要进行友元申明，给它访问权限。 9.3 递增递减运算符重载 重载运算符函数中空参数，可以理解为将this作为右操作数。 后置++运算符重载，需要一个int占位，来区分前置和后置的重载。 要注意前置和后置两种重载的返回类型。 class test{ friend inline ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;out, test a); public: test(){ age = 10; } // 重载前置++ 必须要返回引用 test\u0026amp; operator++(){ // 没有占位的就当作this是右操作数 age++; return *this; } // 重载后置++，不用返回引用，因为返回去可能就看一下值是多少，this本身还是做了+1的。 test operator++ (int){ // this本身作为左值了， 右侧搞一个int来占位 test tmp = *this; age++; return tmp; } private: int age; }; inline ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;out, test a){ out \u0026lt;\u0026lt; a.age; return out; } 9.4 赋值运算符重载 c++编译器至少添加4个默认的函数。\n默认构造函数、析构函数、拷贝构造函数、赋值运算符（对属性进行浅拷贝）。\n要注意如果有堆区数据的话，在重载赋值运算符的时候需要对堆取数据进行深拷贝。\n要注意a = b = c的情况，也就是赋值运算符的重载函数需要有一个返回值引用。\ntest\u0026amp; operator= (test \u0026amp;a) { if(age != nullptr){ delete age; age = nullptr; } // 深拷贝 age = new int(*a.age); return *this; // 连续赋值 } 9.5 关系运算符重载 没什么特殊的\n9.6 函数调用运算符重载 函数调用运算符：就是小括号（），也可以重载。 由于重载后使用的方式非常像函数的调用，因此也称仿函数（STL中使用的较多）。 仿函数没有固定写法，非常灵活。\n10. 转换函数 目的：将一个类转换成其他类型。 转换函数通常不会修改自身的数据，一般要加上const修饰。\nclass person{ public: operator int() const { return int(1.0); } // 不用写返回类型，因为函数名就是返回的类型。 // 一般都加上const修饰 }; person f; int a = 4 + f; // 尝试将f转换为int型。调用了类中的重载函数。 // int a = f + 4; // 这句话则是尝试将4转换成person的类型，需要用到转换构造函数。 11.转换构造函数 真实名字叫non-explicit-one-argument-constructor\n","permalink":"https://Clay-Hex.github.io/posts/2021/02/cpp-class/","summary":"0. 类的4个默认函数 4个函数：构造函数、析构函数、拷贝构造函数、赋值号重载函数。 在定义类时，如果没有自定义这些函数，编译器会提供默认的函数，在默认的函数中，构造函数、析构函数默认空实现，拷贝构造函数、赋值号重载函数默认是浅拷贝。 拷贝构造函数作用： 参数是一个同类型的对象，直接拷贝这个","title":"C++学习记录(5) 类"},{"content":"0. 引用的本质 本质：引用在C++内部的实现是一个指针常量（* const）。 const就限制了必须要初始化，并且初始化以后不可更改。\n它不是一个对象，所以没有引用的引用。\n1. 注意事项 引用必须初始化 引用在初始化后不可修改 2. 引用做函数参数 与指针传递相似\n3. 引用做函数返回值 与指针一样，不要返回局部变量（栈区空间）的引用 函数的调用可以作为左值 int\u0026amp; test(){ static int a = 10; return a; } int main(){ int \u0026amp;ss = test(); test() = 100; // 引用作为左值 cout \u0026lt;\u0026lt; ss \u0026lt;\u0026lt; endl; // 输出100 return 0; } 4. 常量引用 作用：在函数中用来修饰形参，防止误操作。\n","permalink":"https://Clay-Hex.github.io/posts/2021/02/cpp-reference/","summary":"0. 引用的本质 本质：引用在C++内部的实现是一个指针常量（* const）。 const就限制了必须要初始化，并且初始化以后不可更改。 它不是一个对象，所以没有引用的引用。 1. 注意事项 引用必须初始化 引用在初始化后不可修改 2. 引用做函数参数 与指针传递相似 3. 引用做函数返回值 与指针一样，不要返回局","title":"C++学习记录(4) 引用"},{"content":"两个比较容易混淆的概念。\n0. 记忆方法 const int * p; int * const p; int const * p; 这是常见的三种写法，按照从左至右的顺序记忆，按照从右至左的顺序理解。\n记忆 只关注const 和 * 的先后先后顺序，const读做常量，*读做指针。\n参考《Effective c++》Item21上的做法，如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。\n比如\nconst int * p; // 常量指针 int * const p;\t// 指针常量 int const * p; // 常量指针 理解 将 * 读做指向。\nconst int * p; // p指向一个const int * const p; // 常量p 指向一个 int int const * p; // p指向一个const 1. 指针常量 int * const p; // 常量p 指向一个 int 重点在“常量”，这是一个常量，也是一个指针，也就是说，这个指针一旦指向了一个地址，那么它就不可以再指向别的地址空间。\n2. 常量指针 const int * p; // p指向一个const int const * p; // p指向一个const 重点在“指针”，这是一个用const修饰的指针，它既可以指向常量，也可以指向变量。 所谓的“常量”指针或者“常量”引用，不过是指针或引用“自以为是”罢了，只是不能通过该指针或引用来修改对象的值。\ncode:\nint a = 15; const int *p = \u0026amp;a; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; output:\n15 通过指针修改 int a = 15; const int *p = \u0026amp;a; *p = 10; // 通过常量指针修改 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; output:\n编译报错 通过变量自身修改 int a = 15; const int *p = \u0026amp;a; a = 10; // 通过变量自身修改 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; output:\n10 3. 底层const和顶层const 对于一个指针对象来说，它本身可以是const的，也就是说它只可以指向初始化的地址，不可以再指向其他地址空间。另外，指针所指的对象也可以是const的，这就叫底层const，也就是说它所指的地址空间或者对象是不可以通过它修改的（前边说过，这是“自以为是”的）。\n在执行拷贝操作时，顶层const不受影响，拷入和拷出的对象是否是常量没有关系。 而底层const不可以，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换为常量，反之则不行。\n几个转换的例子\n// 变量声明 const int v2 = 0; int v1 = v2; int *p1 = \u0026amp;v1, \u0026amp;r1 = v1; const int *p2 = \u0026amp;v2, *const p3 = \u0026amp;i, \u0026amp;r2 = v2; // 下列哪些是合法的？ r1 = v2; // 合法 p1 = p2; // 不合法，p1是变量，p2是底层const。二者要么都有底层const，要么是变量赋给常量。 p2 = p1; // 合法， p1是变量，p2是底层const。执行的是变量转到常量。 p1 = p3; // 不合法，p1是变量，p3是顶层const+底层const，二者要么都有底层const，要么是变量赋给常量。 p2 = p3; // 合法，p2是底层const，p3是顶层const+底层const，二者都有底层const资格。 4. 通过地址修改const修饰的变量 使用const修饰变量以后，该变量就成为了一个常量。使用赋值的方式对该变量直接进行修改是行不通的。但是可以通过变量的地址进行修改（做一次强制类型转换）。\nconst int a = 2; int *p = const_cast\u0026lt;int*\u0026gt;(\u0026amp;a); (*p)++; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (*p) \u0026lt;\u0026lt; endl; 上边代码输出的是\n2 3 为什么？ 再次输出变量a的地址和p所指向的地址，也是相同的。但是输出的时候a却显示3。原因在于：C++中的常量折叠。指const变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。\n","permalink":"https://Clay-Hex.github.io/posts/2021/02/cpp-constant-pointer-and-pointer-constant/","summary":"两个比较容易混淆的概念。 0. 记忆方法 const int * p; int * const p; int const * p; 这是常见的三种写法，按照从左至右的顺序记忆，按照从右至左的顺序理解。 记忆 只关注const 和 * 的先后先后顺序，const读做常量，*读做指针。 参考《Effective c++》Item21上的做法，如果const位于星号的左侧","title":"C++学习记录(3) 常量指针与指针常量"},{"content":"1. 单调栈 1.1 可解决的问题 单调栈的使用场景时分有限，只处理一种典型的问题，叫做 Next Greater Element。 例如：在一个数组中，每个数左边（右边）第一个比它大（小）的数是什么。\n1.2 详解 直接上例子解释它。\n题目：给出一个原始数组 a[3, 4, 2, 7, 5]，输出每个数左边第一个比它小的数，如果不存在则输出-1。\n解释：第一个3左边没有数，答案是-1，4左边第一个小的数是3，2左边没有比2小的数，答案是-1，7左边第一个小的数是2，5左边第一个小的数是2，所以最后答案是[-1, 3, -1, 2, 2]。\n1.2.0 暴力做法 首先，一般的暴力做法是遍历整个数组，遍历到某个数时，从它开始向前遍历，找到第一个比它小的数，但是这样做的时间复杂度是O(n^2)。\n1.2.1 优化的思路 在遍历时，我们考虑一种情况：已经遍历的元素呈“左大右小”。\n假设此时已经遍历过的元素是[···, 4， 2]（左大右小），那么，如果当前遍历到的元素是5（比2和4都要大），那么肯定答案取2； 如果当前遍历到的元素是3（介于2和4之间），那么答案肯定取2； 如果当前遍历到的元素是1（比2和4都要小），那么相当于又重复了最开始左大右小的假设，所以这种情况不考虑。\n从上述假设可以看出，无论怎么样，只要 2 存在，4就永远不会是答案，可以得出结论：如果已经遍历的元素呈单调减的状态，那么其实只有最小的那个才有用（最右边的最小），其他左边的元素都不用再考虑了。\n其实，在朴素的解法中，已经遍历的元素是杂乱无章的，既有左大右小，也有左小右大，通过上面的优化思路可以看出，在本题中“左大右小”是没有意义的，所以我们可以把这种情况过滤掉，只保留“左小右大”的情况，也就是只保留单调增状态。\n1.2.2 为什么是栈？ 从上边优化思路可以看出，对于已经遍历过的元素，我们只在这些元素的尾部进行操作了，过来一个新元素，就用最后的元素进行比较，如果最后的元素比新元素大，那么最后的元素就删除掉，直到全都删除或者删到了一个比新元素小的元素为止。只在一端操作，那这正好符合栈的结构，只在栈顶新增和删除。\n其实，符合这样操作的数据结构也可以是vector、deque等，但是本质上都是用这些数据结构模拟了一个栈。\n1.2.3 模版代码 上边例题的代码\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int n; stack\u0026lt;int\u0026gt; s; int main(){ cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++){ int x; cin \u0026gt;\u0026gt; x; while(!s.empty() \u0026amp;\u0026amp; s.top() \u0026gt;= x) s.pop(); // 一次比较栈顶元素与当前新元素 if(!s.empty()) cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 找到当前元素x左边第一个小的数 else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; s.push(x); // 将x放入栈中 } return 0; } 1.3 右边第一个大（小）的数？ 上边例子是找左边第一个小的数，那么找第一个大的数，只要修改一下栈的单调性即可。\n如果是找右边第一个大或者小的数，那么可以将原始数组从后往前遍历，就转换到左边第一个大或者小的数这个问题上了。\n1.4 数组是环形的？ 上边例子中，修改一下，找左侧第一个比自己小的数，如果左侧没有就从右侧反向找。这样就相当于一个环形数组。 解决办法就是将原始数组翻倍，将a复制一下连接到自己后边，就可以解决。\n2. 单调队列 2.1 可解决的问题 可以解决滑动窗口问题，例如给定一个长度为n的数组，一个大小为k的滑动窗口，窗口从左向右依次滑动，要求找出每个窗口内的最值。\n2.2 详解 直接上例子解释它。\n题目：给出一个原始数组 a[1, 3, -1, -3, 5, 3, 6, 7]，窗口大小 k = 3，窗口每次向右滑动 1 个位置，输出窗口在每个位置时，窗口中的最小值。\n解释：\n窗口位置 最小值 [1 3 -1] -3 5 3 6 7 -1 1 [3 -1 -3] 5 3 6 7 -3 1 3 [-1 -3 5] 3 6 7 -3 1 3 -1 [-3 5 3] 6 7 -3 1 3 -1 -3 [5 3 6] 7 3 1 3 -1 -3 5 [3 6 7] 3 2.2.0 暴力做法 遍历数组a中每个元素，遍历到某个元素时，遍历包括它自己以及前边的一共 k 个元素，找到最小的。\n2.2.1 优化思路 遍历时，我们依然考虑一种情况：已经遍历的元素呈“左大右小”。\n假设窗口长度k = 3，此时已经遍历过的元素是[4，2]（左大右小），那么，如果当前遍历到的元素是5（比2和4都要大），那么当前窗口为 [4, 2, 5] ,肯定答案取2；\n如果当前遍历到的元素是3（介于2和4之间），那么当前窗口为 [4, 2, 3] ，答案肯定取2；\n如果当前遍历到的元素是1（比2和4都要小），那么当前窗口为 [4, 2, 1] ，答案肯定取1；\n从上述假设可以看出，无论怎么样，只要 2 存在，4就永远不会是答案，除非2已经不在窗口中了，如果2不在窗口中，那么4肯定早就不在窗口中了。 可以得出结论：如果窗口内的元素呈单调减的状态，那么其实只有最小的那个才有用，其他左边的元素都不用再考虑了。\n在朴素的解法中，窗口内的元素是杂乱无章的，既有左大右小，也有左小右大，通过上面的优化思路可以看出，在本题中“左大右小”是没有意义的，所以我们可以把这种情况过滤掉，只保留“左小右大”的情况，也就是只保留单调增状态。\n过滤掉了一部分元素，那么窗口内的元素肯定变少了，就不是题目说的固定长度k了，所以我们可以假想出有一个长度可变的窗口，它的最大长度是k，这个窗口内的元素单调递增（从左向右看是单调递增）。\n可变窗口的最左边元素维护的就是“到当前位置为止，前k个元素中的最小值”。\n2.2.2 为什么是队列？ 这里可以参考上边单调栈的解释，单调栈是在一端进行新增和删除。而对于我们假想出来的这个窗口来说，不仅要在一端进行新增和删除，还需要随时在另一端取出第一个元素。\n那这正好符合双端队列deque的特点，双端队列，两端都可以进行删除、新增，并且可以查询队首元素。\n符合这样操作的数据结构也可以是vector等，但是本质上都是用这些数据结构模拟了一个双端队列。\n2.2.3 模板代码 #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 5; int n, k, q[N], a[N]; int hh = 0, tt = -1; // 队列头和尾 队列存储的是下标 int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 0; i \u0026lt; n; i++){ if(tt \u0026gt;= hh \u0026amp;\u0026amp; q[hh] \u0026lt; i - k + 1) hh++; // 判断队首是否 延后于 窗口 while(tt \u0026gt;= hh \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; // 处理当前的第 i个数 这两行保证队列单调 q[++tt] = i; if(i \u0026gt;= k - 1) cout \u0026lt;\u0026lt; a[q[hh]] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 满一个窗口才开始输出结果 } return 0; } ","permalink":"https://Clay-Hex.github.io/posts/2021/02/monotone-stack-monotone-queue/","summary":"1. 单调栈 1.1 可解决的问题 单调栈的使用场景时分有限，只处理一种典型的问题，叫做 Next Greater Element。 例如：在一个数组中，每个数左边（右边）第一个比它大（小）的数是什么。 1.2 详解 直接上例子解释它。 题目：给出一个原始数组 a[3, 4, 2, 7, 5]，输出每个数左边第一个比它小的数，如果不存在则输出-1。 解释","title":"单调栈与单调队列详解"},{"content":"Lambda表达式 Lambda表达式\n形式 [capture](params) -\u0026gt; return-type{ function body } 说明 capture 需要捕获的外部变量列表（这里的外部变量不包括程序的全局变量，指的是匿名函数父作用域内的变量）。 如果这个匿名函数需要调用本匿名函数以外的变量，那么就需要在这个[ ] 中进行捕获，捕获包括捕获的变量名称和捕获的方式（值和引用）。 例如：\n[ ] 表示不捕获外部的任何变量 [=] 表示捕获外部的所有变量（父作用域内），是以值的方式捕获（不可修改）。 [\u0026amp;] 表示捕获外部的所有变量（父作用域内），是以引用的方式捕获（可修改）。 [=, \u0026amp;x, \u0026amp;y] 表示捕获外部的所有变量（父作用域内），其中x和y以引用的方式捕获，其他变量以值的方式捕获。 [\u0026amp;, x, y] 表示捕获外部的所有变量（父作用域内），其中x和y以值的方式捕获，其他变量以引用的方式捕获。 capture注意事项 如果不进行变量捕获，那么在匿名函数内，不可以使用外部变量。 捕获列表内，不允许重复捕获。比如 [=, a]，=已经说明所有的变量（包括a）以值的方式捕获，后边的a又进行了一次说明，这是不允许的。 捕获任何非父作用域内变量或者程序的全局变量，都会出错。 [this]只能以值的方式捕获\nparams 参数列表，就是和一般的函数一样的参数列表。\nreturn-type 匿名函数的返回类型。 返回类型可以省略，c++11可以根据函数体内部的return 自动判断，当然，也可以指定返回类型。\n总结 如果需要用到匿名函数外部的变量，就必须要进行捕获，需要注意捕获方式（值和引用），其他方面和一般的函数没有太大区别。\n","permalink":"https://Clay-Hex.github.io/posts/2021/01/cpp-lambda-function/","summary":"Lambda表达式 Lambda表达式 形式 [capture](params) -\u0026gt; return-type{ function body } 说明 capture 需要捕获的外部变量列表（这里的外部变量不包括程序的全局变量，指的是匿名函数父作用域内的变量）。 如果这个匿名函数需要调用本匿名函数以外的变量，那么就需要在这个[ ] 中进行捕获，捕获包括捕获的变量名称和捕获的方式（值和引用）。 例","title":"C++学习记录(2) Lambda表达式（匿名函数）"},{"content":"0. 重构 重构是对程序内部的架构的调整。 重构强调的是在不改变\u0026quot;软件外部可观察的行为\u0026quot;前提下，对内部结构进行调整，使得从程序的外部功能上看，没有任何变化。 如下例子： 重构前代码如下：\n#include \u0026lt;iostream\u0026gt; class child { private: public: child(){}; void func(){ std::cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; std::endl; } }; int main(int argc, char const *argv[]) { child a; a.func(); return 0; } 程序运行后，输出123. 重构后的代码如下：\n#include \u0026lt;iostream\u0026gt; class child { private: public: child(){}; void f1(){std::cout \u0026lt;\u0026lt; 1;} void f2(){std::cout \u0026lt;\u0026lt; 2;} void f3(){std::cout \u0026lt;\u0026lt; 3;} void func(){ f1(); f2(); f3(); std::cout \u0026lt;\u0026lt; std::endl; } }; int main(int argc, char const *argv[]) { child a; a.func(); return 0; } main函数执行的时候，依然是调用a的func方法，程序的输出也是123，对于外部来说没有任何改变，但是func内部的实现方式已经改变。\n1. 重写 重写（override）也叫覆盖。\n明确一个概念：“函数签名”，函数签名不仅仅包括函数名，还包括函数的参数、参数的个数、参数的顺序、所在命名空间等信息。但是函数签名不包括函数的返回值类型，如果两个函数除了返回值类型不同以外，其他都一模一样，这在C++中是不被允许的。\n重写是指不改变函数签名，改变的是一个函数内部。如下代码：\n#include \u0026lt;iostream\u0026gt; class parent { private: public: parent(){}; virtual void func(){ std::cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; std::endl; } }; class child : parent{ public: void func(){ std::cout \u0026lt;\u0026lt; 456 \u0026lt;\u0026lt; std::endl; } }; int main(int argc, char const *argv[]) { child a; a.func(); return 0; } child继承parent类，重写了类内的func方法，没有改变函数签名，只改变函数内部代码。\n2. 重载 重载是指不改变函数名，但改变函数的参数、参数个数、参数顺序。重载改变了函数的签名。\n两个同名函数要在同一个作用域下 两个函数只有返回值不同，这是不允许的 重载函数有默认参数的时候，语法上是可以通过的，但是调用函数可能会出现二义性，编译不允许。 代码如下：\n#include \u0026lt;iostream\u0026gt; class parent { private: public: parent(){}; virtual void func(){ std::cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; std::endl; } }; class child : parent{ public: void func(int a){ std::cout \u0026lt;\u0026lt; 456 \u0026lt;\u0026lt; std::endl; } }; int main(int argc, char const *argv[]) { child a; a.func(12); return 0; } child继承parent类，重载了类内的func方法，改变了函数签名（增加了一个参数），方法内部代码可以改变也可以不改变，但是不改变。\n","permalink":"https://Clay-Hex.github.io/posts/2021/01/cpp-override-overload-refactoring/","summary":"0. 重构 重构是对程序内部的架构的调整。 重构强调的是在不改变\u0026quot;软件外部可观察的行为\u0026quot;前提下，对内部结构进行调整，使得从程序的外部功能上看，没有任何变化。 如下例子： 重构前代码如下： #include \u0026lt;iostream\u0026gt; class child { private: public: child(){}; void func(){ std::cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; std::endl; } }; int main(int argc, char const *argv[]) { child a; a.func(); return 0; } 程序运行后，输出123. 重","title":"C++学习记录(1) 重写、重载、重构三者区别"},{"content":"0. 欧几里得算法 欧几里得算法用于求解两个数的最大公约数。代码如下:\nint gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b); } 当b为0时，结束递归，此时a即为a和b的最大公约数。\n1. 裴蜀定理 定理内容：\n如果a、b均是整数，则一定存在整数x和y，使得ax + by = gcd(a, b)成立。\n我们可以再深层次的理解一下式子ax + by = gcd(a, b)的含义，也就是说，整数a和整数b进行线性运算，可以拼凑出他们的最大公约数。再想一想，是不是也可以拼凑出他们最大公约数的整数倍？是的，可以拼凑出他们最大公约数的在整数倍，只要x和y进行对应的放大或缩小就可以了。 那也就是说，只要等号右侧是gcd(a,b)的整数倍，就一定存在整数x和整数y。（注意这里，后边用扩展欧几里得求解线性同余方程时会用到） 注意定理中说的是一定存在整数x和整数y，但是并没有告诉我们如何找到x和y，扩展欧几里得算法可以找到整数x和整数y。\n2. 扩展欧几里得算法 我们当前想求解的方程是 $$ ax + by = gcd(a, b) \\tag {1} $$ 如果使用传统的欧几里得算法，递归的下一层应该是 $$ bx' + (a \\% b)y' = gcd(b, a \\% b) \\tag{2} $$ 其中 $$gcd(b, a \\% b) = gcd(a, b) $$ 整理一下②式： $$ bx' + (a -(a / b)*b)y' = gcd(a, b)\\\\ ay' + b(x' - (a/b)*b) = gcd(a, b) \\tag{3} $$ ①和③等号右侧相等，所以左侧相等，即： $$ ax + by = ay' + b(x' - (a/b)*y)\\tag{4} $$ 由④式可得： $$ x = y'\\\\ y=x' - (a/b)*y' $$ x\u0026rsquo;和y\u0026rsquo;是下层的答案，所以，只要知道下层的答案，就可以得到本层的x和y。 那么这样递归的出口在哪里？ 出口依然是欧几里得算法的出口，即b为0时，a为a和b的最大公约数。对于方程 $$ ax + by = gcd(a, b) $$ 来说，当b为0时，gcd(a, b)就是a。所以此时x = 1，y任意都可以，通常让y等于0。 综上，我们对原来的欧几里得算法代码进行修改：\nint exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){ if(b == 0){ x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d; } 这里在递归的时候，x和y参数交叉传递，是为了方便代码书写，可以自己捋顺一下。\n3. 扩展欧几里得应用 解二元一次不定方程 上边说到欧几里得可以解决解出裴蜀定理中的x和y，在裴蜀定理中方程为 $$ax+by=gcd(a,b)$$ 等号右侧为a和b的最大公约数，其实这是一种特殊情况，更一般的情况应该是等号右侧是一个任意整数。即 $$ax + by =m（m为任意整数）$$ 对于这个更一般的方程来说，如果m不是gcd(a,b)的整数倍，则没有整数解，如果m是$gcd(a,b)$的$k$倍，则有整数解，且解为 $$ x =k*x_0\\\\ y = k*y_0\\\\ $$ 其中，$x_0$和$y_0$是$ax+by=gcd(a,b)$的结果。 上边扩展欧几里得求出的x和y其实是一组特解。 方程$ax + by = m$的解=通解 + 特解。 特解已经有了，下面对通解进行说明。 现在假设(Xi,Yi)和(Xj, Yj)是不定方程ax + by = m的两组解，则有 $$ a*Xi + b*Yi = m\\\\ a*Xj + b*Yj = m $$ 联立两个方程有 $$ a*Xi + b*Yi = a*Xj + b*Yj\\\\ a(Xi-Xj) = -b(Yi - Yj) $$ 左右两边，同时除以$gcd(a,b)$ $$ \\frac{a}{gcd}(Xi-Xj) = -\\frac{b}{gcd}(Yi-Yj) $$ a和b均除以他们的最大公约数以后的结果互质，所以 $$ \\frac{b}{gcd}是(Xi-Xj)的倍数，而且\\frac{a}{gcd}是-(Yi-Yj) 的倍数。 $$ 可见，任意两个解中的X之差，一定是$\\frac{b}{gcd}$的倍数，Y同理，所以通解为： $$ X = x_0 + \\frac{b}{gcd} * k\\\\ Y = y_0 - \\frac{a}{gcd} * k $$ 其中$x_0$于$y_0$是一组特解。\n最小正整数解 以X为例，要求X大于0，且是满足条件的最小的那个X值，即最小正整数解。 通解为 $$ X = x_0 + \\frac{b}{gcd} * k $$ 变形为 $$ x_0 = X - \\frac{b}{gcd} * k $$ 观察上式，则求原式的最小整数解的问题就转换为求：$x_0$ % $\\frac{b}{gcd}$的正整数结果。 如果$x_0$ % $\\frac{b}{gcd}$的结果是正数，那就已经是最小正整数解了，如果$x_0$ % $\\frac{b}{gcd}$的结果是负数，则再加上一个 $\\frac{b}{gcd}$转成正数即是答案。\n解线性同余方程 线性同余方程：\nax = b(mod m) 即 ax % m = b，求满足条件的x。\n对于这个方程，我们可以转化一下，可以理解为，ax减去m的y倍等于b，即 $$ ax - my = b $$ 这个负号其实可以算作y本身的负号，上式就变成 $$ ax + my = b（这个y不是上式的y，多了个负号） $$ 到了这一步，只要用扩展欧几里得求出x和y就好了呀！\n求逆元 当线性同余方程ax = b(mod m)中，当b = 1，a和m互质时，求出的x就是a的逆元，记作$a^-1$。\n","permalink":"https://Clay-Hex.github.io/posts/2020/09/exgcd-cpp-code/","summary":"0. 欧几里得算法 欧几里得算法用于求解两个数的最大公约数。代码如下: int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b); } 当b为0时，结束递归，此时a即为a和b的最大公约数。 1. 裴蜀定理 定理内容： 如果a、b均是整数，则一定存在整数x和y，使得ax + by = gcd(a, b)成立。 我们可以再深层次的理解一下式子ax + by = gcd(a, b","title":"扩展欧几里得算法详解及C++代码实现"},{"content":"模板代码：\ntypedef long long ll; ll quick_pow(ll a,ll b){ ll res = 1; while(b \u0026gt; 0){ if(b \u0026amp; 1){ res *= a; } a *= a; b \u0026gt;\u0026gt;= 1; } return res; } 这里以a^10为例，说一下对快速幂代码的理解。\n右下角的o表示这是十进制数 这里写错了，图片中不应该是o，应该d，d表示这是十进制数 ，b表示这是二进制数。可以得到以下的几个式子，都是逐步变换得出来的。\n最后一个式子可以很好的理解模板代码，可以看到，等号右侧有4项，这4项的幂次是1010，也就是10的二进制表达的每一位。所以，这就要求出幂指数10的二进制的每一位，而且，最后一个式子中，幂次是0的项（第二项和第四项）其实是1，对结果没有贡献，那我们就可以考虑，求出幂指数10的每一位以后，进行判断，如果这一位是0，那就不予考虑了，如果是1的话，就把这一项乘到原有的结果中，也就是代码中的这几行\nif(b \u0026amp; 1){ res *= a; } } 每次判断以后，要把幂次10向右移1位，准备进行下一次的判断。\nb \u0026gt;\u0026gt;= 1; 观察第四个式子，看每一项的括号里边，当前项就是他右边项的平方，所以这还需要一个变量来控制这个东西，每次自己乘自己就可以了，代码里用的底数a本身。\na *= a; 同理，可以得到快速乘法的代码\nint qmul(int a, int b){ int ans = 0; while(b){ if(b \u0026amp; 1){ ans += a; } a += a; b \u0026gt;\u0026gt;= 1; } return ans; } ","permalink":"https://Clay-Hex.github.io/posts/2020/03/quick-power/","summary":"模板代码： typedef long long ll; ll quick_pow(ll a,ll b){ ll res = 1; while(b \u0026gt; 0){ if(b \u0026amp; 1){ res *= a; } a *= a; b \u0026gt;\u0026gt;= 1; } return res; } 这里以a^10为例，说一下对快速幂代码的理解。 右下角的o表示这是十进制数 这里写错了，图片中不应该是o，应该d，d表示这是十进制数 ，b表示这是二进制数。可以得到以下的几个式子，都是逐步变换得出来的。 最后一个式","title":"对快速幂代码的理解"}]